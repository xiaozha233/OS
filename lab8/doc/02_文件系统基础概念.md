# Lab8 文件系统实验讲义 - 第二部分：文件系统基础概念

> **前置知识**：计算机基本结构、内存管理基础  
> **学习产出**：理解文件系统存在的意义、虚拟文件系统的设计思想、UNIX文件系统的核心抽象

---

## 一、为什么需要文件系统？\[S02]

### 1.1 问题的起源：持久存储的需求

**直觉层**：想象一下，你辛辛苦苦写了一篇论文，如果关机后数据就消失了，那该多可怕！这就是"持久存储"的需求——我们需要把数据保存在即使断电也不会丢失的地方。

**形式层**：
- **内存（RAM）**：易失性存储，断电后数据丢失
- **持久存储设备**：硬盘（HDD/SSD）、U盘、光盘等，断电后数据保留

```
┌─────────────────────────────────────────────────────────────┐
│                     存储层次结构                             │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│    ┌──────────┐     速度快      ┌──────────┐               │
│    │ CPU寄存器 │ ◄──────────── │   缓存    │               │
│    └──────────┘                └──────────┘               │
│         ▲                           ▲                      │
│         │                           │                      │
│    ┌──────────┐                ┌──────────┐               │
│    │  内存RAM  │ ◄──────────── │ 易失性存储│ ← 关机数据丢失 │
│    └──────────┘                └──────────┘               │
│         ▲                                                  │
│         │                                                  │
│    ┌──────────┐                ┌──────────┐               │
│    │ 硬盘/SSD │ ◄──────────── │ 持久存储 │ ← 关机数据保留  │
│    └──────────┘     速度慢     └──────────┘               │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```
\[Fig·S02-1] 存储层次结构与持久性对比

### 1.2 没有文件系统会怎样？

假设没有文件系统，你需要：

1. **手动记录**每段数据在硬盘上的起始位置和长度
2. **手动管理**哪些硬盘空间已被占用、哪些空闲
3. **手动编码**在程序中硬编码这些位置信息

```c
// 没有文件系统时的"恐怖"代码示例
void save_my_essay() {
    // 我记得我的论文从硬盘第 1048576 字节开始，长度 4096 字节
    write_to_disk(1048576, my_essay_data, 4096);
    // 注意：不要忘了在小本本上记录这个位置！
    // 如果小本本丢了，论文就找不回来了...
}
```

**问题**：
- 小本本（记录）丢失 → 数据永久丢失
- 不同程序可能覆盖彼此的数据
- 管理起来极其繁琐、容易出错

### 1.3 文件系统的作用

> **一句话定义**：文件系统 = 操作系统中**管理持久存储设备上数据**的模块

文件系统帮我们做了什么？

| 功能 | 说明 |
|-----|------|
| **抽象** | 用"文件"这个简单概念代替复杂的硬盘块管理 |
| **命名** | 用文件名（如 `essay.txt`）代替硬盘地址 |
| **空间管理** | 自动追踪哪些空间已用、哪些空闲 |
| **权限控制** | 控制谁可以读、写、执行文件 |
| **组织** | 用目录层次结构组织文件 |

---

## 二、设备驱动：屏蔽硬件差异 \[S02]

### 2.1 问题：硬件种类繁多

持久存储设备种类繁多：
- 机械硬盘（HDD）- SATA 接口
- 固态硬盘（SSD）- NVMe 接口
- U盘 - USB 接口
- 光盘 - IDE 接口
- ...

每种设备的物理接口和通信协议都不同！

### 2.2 解决方案：设备驱动

**设备驱动（Device Driver）** 是一层软件，它：
1. 处理具体硬件的细节和协议
2. 向上层提供**统一的简单接口**

```
┌─────────────────────────────────────────────────────┐
│                    应用程序                          │
│            read(硬盘, 位置A, 长度B)                   │
└────────────────────────┬────────────────────────────┘
                         │ ← 统一接口
                         ▼
┌─────────────────────────────────────────────────────┐
│                   设备驱动层                         │
├──────────────┬──────────────┬──────────────────────┤
│   HDD驱动    │    SSD驱动   │     U盘驱动           │
│  (SATA协议)  │  (NVMe协议)  │    (USB协议)          │
└──────────────┴──────────────┴──────────────────────┘
                         │
                         ▼
┌──────────────┬──────────────┬──────────────────────┐
│     HDD      │     SSD      │      U盘             │
└──────────────┴──────────────┴──────────────────────┘
```
\[Fig·S02-2] 设备驱动屏蔽硬件差异

---

## 三、虚拟文件系统（VFS）\[S02]

### 3.1 为什么需要虚拟文件系统？

即使有了设备驱动，我们仍面临一个问题：**不同的文件系统格式**。

- Windows 常用：NTFS、FAT32
- Linux 常用：Ext4、XFS、Btrfs
- macOS 常用：APFS、HFS+
- 网络存储：NFS、SMB
- 本实验：Simple File System (SFS)

每种文件系统有自己的数据组织方式和操作接口。如果应用程序需要针对每种文件系统单独编程，那将是噩梦！

### 3.2 VFS 的设计思想

**虚拟文件系统（Virtual File System，VFS）** 是一个**抽象层**：
- **向上**：为应用程序提供统一的文件操作接口（open、read、write、close）
- **向下**：定义具体文件系统需要实现的接口规范

```
┌─────────────────────────────────────────────────────────────┐
│                      应用程序                                │
│           open("/tmp/file.txt", O_RDONLY)                   │
│           read(fd, buffer, size)                            │
└────────────────────────────┬────────────────────────────────┘
                             │ 统一接口
                             ▼
┌─────────────────────────────────────────────────────────────┐
│                  虚拟文件系统 (VFS)                          │
│    ┌───────────────────────────────────────────────────┐   │
│    │ 通用接口：vfs_open(), vfs_read(), vfs_write() ... │   │
│    │ 核心抽象：inode, dentry, file, superblock          │   │
│    └───────────────────────────────────────────────────┘   │
└────────────────────────────┬────────────────────────────────┘
                             │ inode_ops 接口
        ┌────────────────────┼────────────────────┐
        ▼                    ▼                    ▼
┌───────────────┐   ┌───────────────┐   ┌───────────────┐
│  Ext4 文件系统 │   │  SFS 文件系统  │   │   NFS 网络FS   │
│  ext4_read()  │   │  sfs_read()   │   │  nfs_read()   │
└───────────────┘   └───────────────┘   └───────────────┘
        │                    │                    │
        ▼                    ▼                    ▼
   本地磁盘1            本地磁盘2             网络服务器
```
\[Fig·S02-3] 虚拟文件系统架构：统一接口 + 多种实现

### 3.3 VFS 的实际例子 \[S02]

**例子1：本地与云盘统一访问**

在 Windows 中，OneDrive 云盘可以像本地文件夹一样使用：
- 复制、粘贴、拖拽文件
- 双击打开文件
- 背后实际上是网络传输，但用户感知不到差异

这就是 VFS 的功劳！

**例子2：Linux 中的跨文件系统拷贝** \[S02]

```bash
cp /floppy/TEST /tmp/test
# /floppy 是 MS-DOS 格式的软盘
# /tmp 是 Ext2 格式的硬盘分区
# 用户使用相同的 cp 命令，VFS 在背后处理差异
```

对应的伪代码：
```c
// VFS 让这个操作变得简单
inf = open("/floppy/TEST", O_RDONLY);   // 打开 FAT 文件系统上的文件
outf = open("/tmp/test", O_WRONLY);     // 打开 Ext2 文件系统上的文件
do {
    len = read(inf, buf, 4096);          // 读取（VFS → FAT驱动）
    write(outf, buf, len);               // 写入（VFS → Ext2驱动）
} while (len > 0);
close(inf);
close(outf);
```

---

## 四、UNIX 通用文件模型 \[S02]

UNIX 系统定义了一套**通用文件模型（Common File Model）**，所有具体文件系统都需要遵循这个模型。ucore 的文件系统也采用了类似设计。

### 4.1 四大核心抽象

| 抽象概念 | 英文 | 作用 | 存储位置 |
|---------|------|------|---------|
| **超级块** | superblock | 描述整个文件系统的全局信息 | 磁盘 |
| **索引节点** | inode | 描述一个文件的元数据和数据位置 | 磁盘 + 内存缓存 |
| **目录项** | dentry | 维护"文件名 → inode"的映射 | 主要在内存 |
| **文件对象** | file | 描述进程与打开文件的关系 | 仅在内存 |

\[Fig·S02-4] UNIX 文件模型四大核心抽象

### 4.2 知识卡片：超级块（Superblock）

---
**名称**：超级块（Superblock）

**要解决的问题**：存储整个文件系统的"身份证"和全局统计信息

**类比/直觉**：  
想象你是一个图书馆管理员。超级块就像图书馆的"馆藏概况表"：
- 图书馆名称（文件系统类型标识）
- 总共有多少书架（总块数）
- 还有多少空书架（空闲块数）
- 图书馆的布局规则

**形式化表述**：
```c
// kern/fs/sfs/sfs.h - SFS 的超级块定义
struct sfs_super {
    uint32_t magic;                      // 魔数，用于验证文件系统类型
    uint32_t blocks;                     // 总块数
    uint32_t unused_blocks;              // 未使用块数
    char info[SFS_MAX_INFO_LEN + 1];     // 文件系统描述信息
};
```

**关键点**：
- `magic = 0x2f8dbe2a` 是 SFS 的"指纹"，用于识别磁盘是否是有效的 SFS 格式
- 超级块位于磁盘的**第 0 个块**

**一句话带走**：超级块是文件系统的"户口本"，记录全局信息。

---

### 4.3 知识卡片：索引节点（Inode）

---
**名称**：索引节点（Index Node，简称 inode）

**要解决的问题**：记录一个文件的所有元数据（除了文件名以外的一切）

**类比/直觉**：  
inode 就像一个人的"档案"：
- 身高体重（文件大小）
- 职业（文件类型：普通文件/目录）
- 住址（数据块位置）
- 身份证号（inode 编号，唯一标识）

注意：**文件名不在 inode 中**！就像档案里不一定记录姓名——姓名是通过"花名册"（目录项）来关联的。

**形式化表述（磁盘上的 inode）**：
```c
// kern/fs/sfs/sfs.h - 磁盘上的 inode 结构
struct sfs_disk_inode {
    uint32_t size;                       // 文件大小（字节）
    uint16_t type;                       // 文件类型（文件/目录/链接）
    uint16_t nlinks;                     // 硬链接数
    uint32_t blocks;                     // 占用的数据块数
    uint32_t direct[SFS_NDIRECT];        // 直接索引（12个）
    uint32_t indirect;                   // 一级间接索引
};
```

**内联小图**：inode 的数据索引结构

```
                    ┌─────────────────────┐
                    │   sfs_disk_inode    │
                    ├─────────────────────┤
                    │ size: 50000         │
                    │ type: SFS_TYPE_FILE │
                    │ blocks: 15          │
                    ├─────────────────────┤
  直接索引          │ direct[0]  ──────────┼───► 数据块 #101
  (12个)           │ direct[1]  ──────────┼───► 数据块 #102
                    │ ...                 │
                    │ direct[11] ──────────┼───► 数据块 #112
                    ├─────────────────────┤
  一级间接索引      │ indirect ───────────┼───► 间接块 #200
                    └─────────────────────┘          │
                                                     ▼
                                          ┌─────────────────┐
                                          │   间接块 #200   │
                                          ├─────────────────┤
                                          │ [0] ───► #301   │
                                          │ [1] ───► #302   │
                                          │ [2] ───► #303   │
                                          │ ...             │
                                          └─────────────────┘
```
\[Fig·S02-5] SFS inode 的直接索引与间接索引结构

**文件大小计算**：
- 每个块大小：4KB（SFS_BLKSIZE = PGSIZE = 4096）
- 直接索引：12 × 4KB = **48KB**
- 一级间接索引：每个块可存储 4096/4 = 1024 个块号
  - 1024 × 4KB = **4MB**
- **最大文件大小**：48KB + 4MB ≈ **4MB**

**一句话带走**：inode 是文件的"身份档案"，记录元数据和数据位置，但不记录文件名。

---

### 4.4 知识卡片：目录项（Dentry）

---
**名称**：目录项（Directory Entry，简称 dentry）

**要解决的问题**：建立"文件名 → inode"的映射关系

**类比/直觉**：  
目录项就像一个"通讯录"或"花名册"：
- 张三 → 身份证号 001
- 李四 → 身份证号 002

在文件系统中：
- 文件名 "hello.c" → inode 编号 42
- 文件名 "world.c" → inode 编号 43

**形式化表述**：
```c
// kern/fs/sfs/sfs.h - 磁盘上的目录项结构
struct sfs_disk_entry {
    uint32_t ino;                          // 指向的 inode 编号
    char name[SFS_MAX_FNAME_LEN + 1];      // 文件名
};
```

**重要特性**：
- 一个目录本身也是一个文件（类型为 SFS_TYPE_DIR）
- 目录的数据内容就是一个**目录项数组**
- 在 SFS 中，每个目录项占用一个完整的块（简化实现）

```
目录 /home 的结构：
┌────────────────────────────────────┐
│  目录 /home (inode #5, type=DIR)   │
├────────────────────────────────────┤
│  数据块内容：                       │
│  ┌────────────────────────────────┐│
│  │ entry[0]: ino=10, name="alice" ││ → 指向 alice 目录
│  ├────────────────────────────────┤│
│  │ entry[1]: ino=11, name="bob"   ││ → 指向 bob 目录
│  ├────────────────────────────────┤│
│  │ entry[2]: ino=0,  name=""      ││ → 空闲项（ino=0表示无效）
│  └────────────────────────────────┘│
└────────────────────────────────────┘
```
\[Fig·S02-6] 目录结构示例

**一句话带走**：目录项是"文件名到inode"的翻译表。

---

### 4.5 知识卡片：文件对象（File）

---
**名称**：文件对象（File Object）

**要解决的问题**：记录一个进程打开某个文件的状态

**类比/直觉**：  
如果 inode 是一本书的"图书信息卡"，那么 file 就是你的"借书证"：
- 你借了哪本书（指向 inode）
- 你读到哪一页了（读写位置 pos）
- 你可以做什么（只读？只写？读写？）

**形式化表述**：
```c
// kern/fs/file.h
struct file {
    enum {
        FD_NONE, FD_INIT, FD_OPENED, FD_CLOSED,
    } status;                    // 文件状态
    bool readable;               // 是否可读
    bool writable;               // 是否可写
    int fd;                      // 文件描述符
    off_t pos;                   // 当前读写位置
    struct inode *node;          // 指向的 inode
    int open_count;              // 打开计数
};
```

**关键点**：
- file 对象**仅存在于内存中**，进程关闭文件后就消失
- 不同进程可以同时打开同一个文件，各自有独立的 file 对象
- 文件描述符（fd）是进程用来引用 file 对象的整数句柄

**一句话带走**：file 对象是进程与打开文件之间的"会话记录"。

---

### 4.6 四大抽象的关系图

```
┌───────────────────────────────────────────────────────────────────────┐
│                           进程 A                                       │
│   ┌─────────────────────────────────────────────────────────────┐     │
│   │ files_struct                                                 │     │
│   │  ├── fd_array[0] ──► file ─┐                                │     │
│   │  ├── fd_array[1] ──► file ─┼─► inode #42 ◄─ dentry "a.txt"  │     │
│   │  └── fd_array[2] ──► file ─┘     │                          │     │
│   └─────────────────────────────────────────────────────────────┘     │
│                                      │                                 │
│                                      ▼                                 │
│                               sfs_disk_inode                           │
│                               (磁盘上的元数据)                          │
│                                      │                                 │
│                          ┌───────────┴───────────┐                     │
│                          ▼                       ▼                     │
│                    数据块 #101              数据块 #102                 │
│                    (文件实际内容)           (文件实际内容)               │
└───────────────────────────────────────────────────────────────────────┘
                                      │
                                      ▼
                             ┌───────────────┐
                             │  superblock   │
                             │  (文件系统    │
                             │   全局信息)   │
                             └───────────────┘
```
\[Fig·S02-7] 四大抽象的层级关系：file → inode → 数据块，superblock 管理全局

---

## 五、文件与目录的概念 \[S02]

### 5.1 文件的定义

> **文件** = 一段逻辑上相关联的有序字节序列

特点：
- 有一个用户友好的**文件名**（路径）
- 有一个系统内部的**编号**（inode 号）
- 数据可能存储在磁盘的**非连续位置**
- 实际占用空间可能比数据本身多（元数据开销）

### 5.2 目录的定义

> **目录** = 一种特殊的文件，其内容是"文件名 → inode"的映射表

目录形成**树状层次结构**：

```
/                    ← 根目录
├── home/            ← 目录
│   ├── alice/       ← 目录
│   │   └── hello.c  ← 普通文件
│   └── bob/         ← 目录
├── tmp/             ← 目录
└── bin/             ← 目录
    └── sh           ← 可执行文件
```

### 5.3 挂载点（Mount Point）\[S02]

在 UNIX 中，可以把不同的文件系统"挂载"到目录树的某个节点上。

```
主文件系统的目录树：          U盘的文件系统：
        /                      /
       / \                    / \
     home  media            doc  photos
            |
          usb ←── 挂载点

挂载后：
        /
       / \
     home  media
             |
            usb
           / \
         doc  photos
```
\[Fig·S02-8] 挂载点示意图

**一句话理解**：挂载 = 把一个文件系统的根目录"嫁接"到另一个目录下。

---

## 六、魔数（Magic Number）\[S02]

### 6.1 什么是魔数？

**魔数**是文件或数据结构开头的特定值，用于**快速识别数据类型**。

```c
// SFS 的魔数
#define SFS_MAGIC  0x2f8dbe2a
```

### 6.2 魔数的作用

| 文件类型 | 魔数 | 说明 |
|---------|------|------|
| SFS 文件系统 | 0x2f8dbe2a | 验证磁盘是否是 SFS 格式 |
| JPEG 图片 | 0xFFD8 (开头) | 识别图片格式 |
| PDF 文档 | %PDF (开头) | 识别 PDF 文件 |
| Java 类文件 | 0xCAFEBABE | 识别 Java 字节码 |
| ELF 可执行文件 | 0x7F454C46 | 识别 Linux 可执行文件 |

### 6.3 趣味故事：M&M 巧克力豆与魔数 \[S02]

> **摇滚乐队 Van Halen 的故事**：
> 
> 这个乐队在演出合同中有一条奇怪的规定："后台必须提供 M&M 巧克力豆，但**绝对不能有棕色的**。"
>
> 多年后主唱解释：他们的演出设备复杂，合同有大量技术要求。这条"无棕色豆"的规定是一个"魔数"——如果后台有棕色豆，说明主办方**没有仔细阅读合同**，很可能也没有正确准备技术设备。
>
> 这和文件系统的魔数异曲同工：通过检查一个简单的标记，快速判断整体是否合规。

---

## 七、易错点与比较 \[C05]

### 7.1 常见误区

| 误区 | 正确理解 |
|-----|---------|
| 文件名存储在 inode 中 | ❌ 文件名存储在**目录项**中，inode 只有编号 |
| 删除文件就是删除数据 | ❌ 删除文件只是删除目录项，inode 和数据可能还在 |
| file 对象在磁盘上 | ❌ file 对象仅在**内存**中，进程关闭就消失 |
| 每个文件只有一个 file 对象 | ❌ 同一文件可被多个进程打开，各有独立的 file 对象 |

### 7.2 概念对比

| 对比项 | inode | dentry | file |
|-------|-------|--------|------|
| 存储位置 | 磁盘 + 内存缓存 | 主要在内存 | 仅在内存 |
| 生命周期 | 文件存在期间 | 路径解析时创建 | 进程打开到关闭 |
| 关联关系 | 1个文件对应1个inode | 多个dentry可指向1个inode | 多个file可指向1个inode |
| 记录信息 | 文件元数据+数据位置 | 文件名+inode号 | 进程访问状态 |

---

## 八、自测题 \[C06]

**Q1（判断题）**：一个文件可以有多个文件名。
> **答案**：✅ 正确。这就是**硬链接**的概念——多个目录项（不同文件名）可以指向同一个 inode。

**Q2（单选题）**：以下哪个信息不存储在 inode 中？
- A) 文件大小
- B) 文件类型
- C) 文件名
- D) 数据块位置

> **答案**：C) 文件名。文件名存储在目录项（dentry）中。

**Q3（开放题）**：解释为什么 VFS 对操作系统的可扩展性很重要？
> **答案要点**：
> 1. 新增文件系统时，只需实现 VFS 定义的接口，无需修改上层代码
> 2. 应用程序使用统一的 API，不关心底层是什么文件系统
> 3. 可以同时使用多种文件系统，通过挂载点整合到统一的目录树

---

## 九、下一步

完成本部分后，你已理解了文件系统的核心概念！接下来请阅读：

📖 **[03_ucore文件系统架构.md](03_ucore文件系统架构.md)** - 了解 ucore 中文件系统的具体实现

---

**Covered**: S02（文件系统概述、VFS、UNIX文件系统、superblock、inode、dentry、file、目录、挂载点、魔数）
