# Lab8 文件系统实验讲义 - 第八部分：扩展练习与总复习

> **本文档目的**：提供 Challenge 练习的设计思路，以及全面的答辩准备材料  
> **适用人群**：已完成练习1、2，希望拿高分或准备答辩的同学

---

## 一、扩展练习 - UNIX PIPE 机制 \[S10]

### 1.1 任务描述

> **扩展练习 Challenge1：实现 UNIX PIPE 机制**
>
> 在 ucore 中加入类似 UNIX PIPE 的管道机制：
> - 实现管道数据结构和管理接口
> - 支持进程间通过管道进行数据传输
> - 示例：`ls | grep "test"`

### 1.2 PIPE 基本概念

```
┌─────────────────────────────────────────────────────────────────────────┐
│                         UNIX PIPE 机制示意                              │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                         │
│   进程 A (写入端)                        进程 B (读取端)                 │
│  ┌─────────────┐                       ┌─────────────┐                 │
│  │  ls 命令    │                       │ grep 命令   │                 │
│  │             │                       │             │                 │
│  │ write(fd[1],│                       │ read(fd[0], │                 │
│  │  data, len) │                       │  buf, len)  │                 │
│  └──────┬──────┘                       └──────┬──────┘                 │
│         │                                     │                         │
│         │ fd[1] (写端)                        │ fd[0] (读端)            │
│         │                                     │                         │
│         ▼                                     ▼                         │
│  ┌──────────────────────────────────────────────────┐                  │
│  │                    PIPE 缓冲区                    │                  │
│  │  ┌─────┬─────┬─────┬─────┬─────┬─────┬─────┐    │                  │
│  │  │  H  │  e  │  l  │  l  │  o  │  \n │     │    │                  │
│  │  └─────┴─────┴─────┴─────┴─────┴─────┴─────┘    │                  │
│  │   head →                         ← tail          │                  │
│  └──────────────────────────────────────────────────┘                  │
│                                                                         │
│  特点：                                                                  │
│  • 单向数据流（写入端 → 读取端）                                          │
│  • FIFO（先进先出）                                                      │
│  • 有限容量（典型值 4KB ~ 64KB）                                         │
│  • 读写端分别关闭后管道销毁                                               │
│                                                                         │
└─────────────────────────────────────────────────────────────────────────┘
```
\[Fig·S10-1] UNIX PIPE 机制示意

### 1.3 数据结构设计

```c
// 建议添加到 kern/fs/pipe.h

#define PIPE_BUF_SIZE 4096  // 管道缓冲区大小

struct pipe {
    char buffer[PIPE_BUF_SIZE];  // 环形缓冲区
    uint32_t read_pos;            // 读位置
    uint32_t write_pos;           // 写位置
    uint32_t nread;               // 读端引用计数
    uint32_t nwrite;              // 写端引用计数
    sem_t read_sem;               // 读信号量（缓冲区非空）
    sem_t write_sem;              // 写信号量（缓冲区未满）
    lock_t lock;                  // 保护管道数据的锁
};

// 管道 inode 操作函数
struct inode_ops pipe_inode_ops = {
    .vop_read = pipe_read,
    .vop_write = pipe_write,
    .vop_fstat = pipe_fstat,
    .vop_ref_inc = pipe_ref_inc,
    .vop_ref_dec = pipe_ref_dec,
    .vop_open = pipe_open,
    .vop_close = pipe_close,
    // ...
};
```

### 1.4 系统调用接口

```c
// 创建管道
// 返回两个文件描述符：fd[0] 用于读，fd[1] 用于写
int sys_pipe(int fd[2]);

// 实现思路
int sys_pipe(int fd[2]) {
    // 1. 分配 pipe 结构
    struct pipe *p = kmalloc(sizeof(struct pipe));
    
    // 2. 初始化管道
    p->read_pos = p->write_pos = 0;
    p->nread = p->nwrite = 1;
    sem_init(&p->read_sem, 0);
    sem_init(&p->write_sem, PIPE_BUF_SIZE);
    lock_init(&p->lock);
    
    // 3. 创建两个 inode（或一个 pipe_inode 包含两端）
    struct inode *read_inode = pipe_create_inode(p, PIPE_READ);
    struct inode *write_inode = pipe_create_inode(p, PIPE_WRITE);
    
    // 4. 分配文件描述符
    fd[0] = fd_alloc_for_inode(read_inode);
    fd[1] = fd_alloc_for_inode(write_inode);
    
    return 0;
}
```

### 1.5 读写操作实现

```c
// 管道读
static int
pipe_read(struct inode *node, struct iobuf *iob) {
    struct pipe *p = pipe_get_from_inode(node);
    size_t count = iob->io_resid;  // 需要读取的字节数
    size_t nread = 0;
    
    lock_acquire(&p->lock);
    
    while (nread < count) {
        // 等待缓冲区有数据
        while (p->read_pos == p->write_pos && p->nwrite > 0) {
            lock_release(&p->lock);
            down(&p->read_sem);
            lock_acquire(&p->lock);
        }
        
        // 如果写端已关闭且无数据，返回
        if (p->read_pos == p->write_pos && p->nwrite == 0) {
            break;
        }
        
        // 读取一个字节
        char c = p->buffer[p->read_pos % PIPE_BUF_SIZE];
        p->read_pos++;
        
        // 复制到用户缓冲区
        iobuf_move(iob, &c, 1, true, NULL);
        nread++;
        
        // 通知写端缓冲区有空间
        up(&p->write_sem);
    }
    
    lock_release(&p->lock);
    return 0;
}

// 管道写
static int
pipe_write(struct inode *node, struct iobuf *iob) {
    struct pipe *p = pipe_get_from_inode(node);
    size_t count = iob->io_resid;
    size_t nwritten = 0;
    
    lock_acquire(&p->lock);
    
    while (nwritten < count) {
        // 如果读端已关闭，返回错误（SIGPIPE）
        if (p->nread == 0) {
            lock_release(&p->lock);
            return -E_PIPE;
        }
        
        // 等待缓冲区有空间
        while (p->write_pos - p->read_pos >= PIPE_BUF_SIZE) {
            lock_release(&p->lock);
            down(&p->write_sem);
            lock_acquire(&p->lock);
        }
        
        // 写入一个字节
        char c;
        iobuf_move(iob, &c, 1, false, NULL);
        p->buffer[p->write_pos % PIPE_BUF_SIZE] = c;
        p->write_pos++;
        nwritten++;
        
        // 通知读端有数据
        up(&p->read_sem);
    }
    
    lock_release(&p->lock);
    return 0;
}
```

---

## 二、扩展练习 - UNIX LINK 机制 \[S10]

### 2.1 任务描述

> **扩展练习 Challenge2：实现 UNIX Hard Link 和 Soft Link**
>
> - Hard Link：多个文件名指向同一个 inode
> - Soft Link（符号链接）：一个文件存储另一个文件的路径

### 2.2 Hard Link vs Soft Link

```
┌─────────────────────────────────────────────────────────────────────────┐
│                    Hard Link vs Soft Link                               │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                         │
│  Hard Link:                                                             │
│  ┌─────────┐    ┌─────────┐                                            │
│  │ "file1" │    │ "file2" │     两个目录项                              │
│  └────┬────┘    └────┬────┘                                            │
│       │              │                                                  │
│       │              │                                                  │
│       ▼              ▼                                                  │
│  ┌────────────────────────────┐                                        │
│  │        inode #42           │  同一个 inode                           │
│  │   nlinks = 2               │  引用计数 = 2                           │
│  │   data blocks: [...]       │                                        │
│  └────────────────────────────┘                                        │
│                                                                         │
│  特点：                                                                  │
│  • 两个文件名完全等价                                                    │
│  • 删除一个不影响另一个                                                  │
│  • 不能跨文件系统                                                        │
│  • 不能链接目录（防止环）                                                │
│                                                                         │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                         │
│  Soft Link:                                                             │
│  ┌─────────┐                                                           │
│  │ "link"  │    目录项                                                  │
│  └────┬────┘                                                           │
│       │                                                                 │
│       ▼                                                                 │
│  ┌────────────────────────────┐                                        │
│  │      inode #100            │  链接文件的 inode                       │
│  │  type = SYMLINK            │  类型：符号链接                         │
│  │  data = "/path/to/target"  │  内容：目标路径                         │
│  └────────────────────────────┘                                        │
│       │                                                                 │
│       │ 访问时解析路径                                                   │
│       ▼                                                                 │
│  ┌─────────┐                                                           │
│  │ "target"│    实际目标文件                                            │
│  └────┬────┘                                                           │
│       │                                                                 │
│       ▼                                                                 │
│  ┌────────────────────────────┐                                        │
│  │        inode #42           │  目标文件的 inode                       │
│  │   data blocks: [...]       │                                        │
│  └────────────────────────────┘                                        │
│                                                                         │
│  特点：                                                                  │
│  • 可以跨文件系统                                                        │
│  • 可以链接目录                                                          │
│  • 目标删除后链接失效（悬空链接）                                         │
│                                                                         │
└─────────────────────────────────────────────────────────────────────────┘
```
\[Fig·S10-2] Hard Link 与 Soft Link 对比

### 2.3 Hard Link 实现

```c
// 系统调用：创建硬链接
// link(old_path, new_path) - 为 old_path 创建新链接 new_path

int sysfile_link(const char *old_path, const char *new_path) {
    int ret;
    struct inode *node;
    
    // 1. 查找源文件的 inode
    if ((ret = vfs_lookup(old_path, &node)) != 0) {
        return ret;
    }
    
    // 2. 检查是否是目录（不允许链接目录）
    if (vop_gettype(node, &type) == 0 && type == S_IFDIR) {
        vop_ref_dec(node);
        return -E_ISDIR;
    }
    
    // 3. 在目标位置创建链接
    ret = vfs_link(old_path, new_path);
    
    vop_ref_dec(node);
    return ret;
}

// SFS 层实现
static int
sfs_link(struct inode *node, const char *name, struct inode *link_node) {
    struct sfs_inode *sin = vop_info(node, sfs_inode);
    struct sfs_fs *sfs = fsop_info(vop_fs(node), sfs);
    
    // 1. 在目录中添加新条目，指向相同的 ino
    struct sfs_disk_entry entry;
    entry.ino = vop_info(link_node, sfs_inode)->ino;
    strcpy(entry.name, name);
    
    // 2. 增加 inode 的 nlinks 计数
    struct sfs_disk_inode *din = &vop_info(link_node, sfs_inode)->din;
    din->nlinks++;
    sfs_sync_inode(sfs, sin);  // 写回磁盘
    
    return 0;
}
```

### 2.4 Soft Link 实现

```c
// 系统调用：创建符号链接
// symlink(target, linkpath) - 创建指向 target 的符号链接 linkpath

int sysfile_symlink(const char *target, const char *linkpath) {
    // 1. 创建新的符号链接 inode
    struct inode *link_node;
    int ret = vfs_create(linkpath, &link_node);
    
    // 2. 设置类型为符号链接
    // 3. 将 target 路径写入 inode 的数据块
    
    return ret;
}

// 在 sfs_disk_inode 中添加类型
#define SFS_TYPE_FILE   1
#define SFS_TYPE_DIR    2
#define SFS_TYPE_LINK   3  // 符号链接

// 读取符号链接时，需要解析目标路径
static int
sfs_readlink(struct inode *node, struct iobuf *iob) {
    struct sfs_inode *sin = vop_info(node, sfs_inode);
    struct sfs_fs *sfs = fsop_info(vop_fs(node), sfs);
    
    // 符号链接的目标路径存储在数据块中
    // 读取并返回
    return sfs_io_nolock(sfs, sin, iob->io_base, iob->io_resid, 
                         iob->io_offset, 0);
}

// 路径解析时处理符号链接
// 在 vfs_lookup 中添加逻辑
if (inode_type == SFS_TYPE_LINK) {
    char target[SFS_MAX_FNAME_LEN];
    vop_readlink(node, target, sizeof(target));
    // 递归解析 target 路径
    // 注意：需要限制递归深度防止死循环
}
```

---

## 三、知识速查表（答辩准备）\[C15]

### 3.1 四层架构速记

| 层次 | 主要结构 | 核心函数 | 记忆口诀 |
|-----|---------|---------|---------|
| 用户接口层 | fd, file | open/read/write/close | "用户看到的是 fd" |
| VFS 层 | inode, inode_ops | vfs_open, vfs_lookup | "统一抽象是 inode" |
| SFS 层 | sfs_inode, sfs_disk_* | sfs_io_nolock | "磁盘存储是 SFS" |
| 设备层 | device, stdin/stdout/disk0 | dop_io | "底层设备是 device" |

### 3.2 重要数据结构速记

```
文件描述符 fd (整数)
    ↓ current->files->fd_array[fd]
struct file {
    fd, status, pos, node
}
    ↓ file->node
struct inode {
    ref_count, open_count
    in_ops (函数指针表)
    in_info (联合体：sfs_inode 或 device)
}
    ↓ 如果是 SFS
struct sfs_inode {
    din (磁盘 inode 内容)
    dirty, reclaim_count
    ino (inode 编号)
}
    ↓ sin->din
struct sfs_disk_inode {
    size, type, nlinks
    blocks, direct[12], indirect
}
```

### 3.3 SFS 磁盘布局速记

```
Block 0: superblock (magic=0x2f8dbe2a, nblocks, nunused, freemap_blocks)
Block 1~: freemap (位图，1=已用，0=空闲)
Block X: root-dir inode (ino=0)
Block X+1~: data blocks
```

### 3.4 关键函数调用链

**open 调用链**：
```
user: open() → syscall(SYS_open) → 
kernel: sys_open() → sysfile_open() → file_open() → vfs_open() → 
        vfs_lookup() → sfs_lookup() → sfs_dirent_search_nolock()
```

**read 调用链**：
```
user: read() → syscall(SYS_read) → 
kernel: sys_read() → sysfile_read() → file_read() → vop_read() → 
        sfs_read() → sfs_io() → sfs_io_nolock()
```

**exec 调用链**：
```
user: execve() → syscall(SYS_exec) → 
kernel: sys_exec() → do_execve() → load_icode(fd, argc, kargv) → 
        load_icode_read() → sysfile_read() → ... → sfs_io_nolock()
```

### 3.5 练习1 关键点

| 要点 | 说明 |
|-----|------|
| 函数位置 | `kern/fs/sfs/sfs_inode.c: sfs_io_nolock()` |
| 输入参数 | sfs, sin, buf, len, offset, write |
| 核心逻辑 | 按块遍历，处理首块/中间块/尾块 |
| 首块处理 | 可能不从块首开始，需要 blkoff |
| 中间块 | 整块读写，大小 = SFS_BLKSIZE |
| 尾块处理 | 可能不到块尾，计算剩余字节 |
| 返回值 | alen_store 记录实际读写字节数 |

### 3.6 练习2 关键点

| 要点 | 说明 |
|-----|------|
| 函数位置 | `kern/process/proc.c: load_icode()` |
| 与 Lab5 区别 | 从文件读取，处理 argc/argv |
| 读文件函数 | `load_icode_read(fd, buf, len, offset)` |
| ELF 解析 | 读 elfhdr → 遍历 proghdr → 加载 PT_LOAD 段 |
| BSS 处理 | p_memsz > p_filesz 部分需清零 |
| 用户栈 | 需设置 argc/argv，通过 a0/a1 传递 |
| trapframe | epc=入口，sp=用户栈，status=用户态 |

---

## 四、答辩常见问题 \[C15]

### Q1: VFS 是什么？为什么需要 VFS？

**答**：VFS（Virtual File System，虚拟文件系统）是操作系统提供的一个抽象层，它为各种不同的文件系统提供统一的接口。

需要 VFS 的原因：
1. **统一接口**：用户程序只需要使用 open/read/write 等统一接口，不需要关心底层是哪种文件系统
2. **支持多种 FS**：可以同时挂载 ext4、ntfs、sfs 等不同文件系统
3. **设备抽象**：将设备也抽象为文件，实现"一切皆文件"的理念

### Q2: inode 和 dentry 有什么区别？

**答**：
- **inode**：存储文件的元数据（大小、权限、数据块位置等），不包含文件名
- **dentry**（目录项）：存储文件名和对应的 inode 编号

一个 inode 可以对应多个 dentry（硬链接），但一个 dentry 只能对应一个 inode。

### Q3: 解释 sfs_io_nolock 中 blkoff 的作用

**答**：`blkoff` 是偏移量在块内的位置（`offset % SFS_BLKSIZE`）。

它的作用是处理**非块对齐**的情况：
- 当 blkoff ≠ 0 时，说明起始位置不在块首，需要跳过块的前 blkoff 字节
- 第一个块的读取量 = min(SFS_BLKSIZE - blkoff, endpos - offset)

### Q4: load_icode 中为什么需要 sysfile_close(fd)？

**答**：因为加载完程序后，这个文件描述符在新进程中不再需要。
- load_icode 是通过 do_execve 调用的
- 新程序有自己的文件描述符表（从父进程继承）
- 用于加载的这个 fd 是内核打开的，需要及时关闭避免资源泄露

### Q5: 为什么 SFS 限制文件最大约 4MB？

**答**：SFS 使用 12 个直接块 + 1 个一级间接块的索引结构：
- 直接块：12 × 4KB = 48KB
- 间接块：1024 × 4KB = 4MB（一个 4KB 块可存 1024 个块号）
- 总计约 4MB

如果要支持更大文件，需要添加二级间接块或三级间接块。

### Q6: 简述 open("file", O_RDWR) 的完整执行流程

**答**：
1. 用户态调用 open()，触发系统调用 SYS_open
2. 内核 sys_open() → sysfile_open() → file_open()
3. file_open() 调用 vfs_open()，解析路径找到 inode
4. vfs_open() 调用 vop_open()（实际调用 sfs_openfile）
5. sfs_openfile() 检查权限，增加引用计数
6. 分配 file 结构，填入 fd_array
7. 返回文件描述符 fd 给用户

### Q7: 硬链接和符号链接的区别？

**答**：

| 对比项 | 硬链接 | 符号链接 |
|-------|-------|---------|
| 本质 | 同一个 inode 的不同文件名 | 存储目标路径的特殊文件 |
| 跨文件系统 | 不可以 | 可以 |
| 链接目录 | 不允许 | 允许 |
| 目标删除 | 不受影响 | 变成悬空链接 |
| inode 数 | 相同 | 不同 |

---

## 五、实验检查清单

### 5.1 代码完成检查

- [ ] **练习1**：`sfs_io_nolock()` 实现完成
  - [ ] 首块处理正确（blkoff）
  - [ ] 中间块处理正确（整块）
  - [ ] 尾块处理正确（剩余字节）
  - [ ] alen_store 正确返回实际字节数

- [ ] **练习2**：`load_icode()` 实现完成
  - [ ] ELF 头部解析正确
  - [ ] 所有 PT_LOAD 段加载正确
  - [ ] BSS 区域清零
  - [ ] 用户栈设置正确
  - [ ] argc/argv 传递正确
  - [ ] trapframe 设置正确
  - [ ] 文件描述符正确关闭

### 5.2 功能测试检查

- [ ] `make qemu` 能够正常启动
- [ ] 出现 `sh` 命令行界面
- [ ] 能执行 `ls` 命令，列出文件
- [ ] 能执行 `hello` 程序
- [ ] 能执行其他用户程序

### 5.3 代码质量检查

- [ ] 无编译警告
- [ ] 代码风格一致
- [ ] 添加了必要注释
- [ ] 错误处理完整

---

## 六、调试技巧总结

### 6.1 常用调试方法

```bash
# 使用 GDB 调试
make debug

# 在 GDB 中设置断点
(gdb) b sfs_io_nolock
(gdb) b load_icode
(gdb) c

# 打印变量
(gdb) p offset
(gdb) p blkno
(gdb) p *elf
```

### 6.2 添加调试输出

```c
// 在关键位置添加调试信息
cprintf("[sfs_io_nolock] offset=%d, len=%d, blkno=%d\n", 
        (int)offset, (int)endpos, (int)blkno);

cprintf("[load_icode] e_entry=0x%lx, phnum=%d\n", 
        elf->e_entry, elf->e_phnum);
```

### 6.3 常见错误排查

| 症状 | 可能原因 | 排查方法 |
|-----|---------|---------|
| 启动 panic | ELF 魔数验证失败 | 检查 load_icode_read 是否正确 |
| 读取数据错误 | sfs_io_nolock 计算错误 | 打印 blkoff, size 检查 |
| 程序无输出 | trapframe 设置错误 | 检查 epc, sp, status |
| segfault | 页表设置错误 | 检查 mm_map 和 pgdir_alloc_page |

---

## 七、总结

Lab8 是 ucore 实验系列的最后一个实验，也是最复杂的一个。通过这个实验，你应该掌握：

1. **文件系统层次结构**：用户接口 → VFS → 具体 FS → 设备
2. **核心数据结构**：file、inode、superblock、dentry
3. **SFS 实现细节**：磁盘布局、块索引、目录结构
4. **系统调用流程**：open、read、write、exec 的完整路径
5. **从文件加载程序**：ELF 解析、内存映射、参数传递

这些知识不仅对答辩有帮助，也是理解 Linux 等真实操作系统的基础。祝你实验顺利！

---

## 文档索引

| 文档 | 主题 | 标签 |
|-----|------|-----|
| [01_概述与学习路线.md](01_概述与学习路线.md) | 实验概述与学习路径 | S01 |
| [02_文件系统基础概念.md](02_文件系统基础概念.md) | 文件系统基础知识 | C01-C05 |
| [03_ucore文件系统架构.md](03_ucore文件系统架构.md) | ucore 四层架构 | C06-C08 |
| [04_SFS文件系统详解.md](04_SFS文件系统详解.md) | SFS 结构与实现 | C09-C11 |
| [05_设备与系统调用.md](05_设备与系统调用.md) | 设备抽象与系统调用 | C12-C13 |
| [06_练习1_sfs_io_nolock实现.md](06_练习1_sfs_io_nolock实现.md) | 练习1 实现指导 | S08 |
| [07_练习2_load_icode实现.md](07_练习2_load_icode实现.md) | 练习2 实现指导 | S09, C14 |
| [08_扩展练习与复习.md](08_扩展练习与复习.md) | Challenge 与答辩准备 | S10, C15 |

---

**全文完。祝实验顺利，答辩成功！**
