# **Lab4 实验报告**


**目录**

1.  [实验背景与目标](#1-实验背景与目标)
2.  [小组成员分工](#2-小组成员分工)
3.  [重要知识点梳理](#3-重要知识点梳理)
    *   [3.1. 实验知识点与OS原理对应分析](#31-实验知识点与os原理对应分析)
    *   [3.2. OS原理中重要但实验未体现的知识点](#32-os原理中重要但实验未体现的知识点)
4.  [练习解答](#4-练习解答)
    *   [4.1. 练习0：填写已有实验](#41-练习0填写已有实验)
    *   [4.2. 练习1：分配并初始化一个进程控制块](#42-练习1分配并初始化一个进程控制块)
    *   [4.3. 练习2：为新创建的内核线程分配资源](#43-练习2为新创建的内核线程分配资源)
    *   [4.4. 练习3：编写 proc_run 函数](#44-练习3编写-proc_run-函数)
5.  [扩展练习 (Challenge)](#5-扩展练习-challenge)
    *   [5.1. `local_intr_save` 开关中断的实现原理](#51-local_intr_save-开关中断的实现原理)
    *   [5.2. `get_pte` 函数设计分析](#52-get_pte-函数设计分析)
6.  [实验总结与体会](#6-实验总结与体会)

---

## 1. 实验背景与目标

本实验在前序物理内存管理和基础页表机制的基础上，迈出了实现“多任务操作系统”的关键一步。此前，ucore 仅能以单一执行流的方式运行。本次实验的核心目标是引入并实现 **CPU 虚拟化**，使内核具备并发执行多个任务的能力。

为达成此目标，实验分为两大核心内容：
1.  **完善虚拟内存管理**：通过引入虚拟内存描述结构（VMA，尽管本次实验应用较浅）和更精细的页表权限管理，为未来进程的地址空间隔离打下基础。内存映射仍采用**预映射**方式。
2.  **实现内核线程机制**：引入**进程控制块 (PCB)**、**上下文切换**和**调度器 (Scheduler)**，将 ucore 从一个“单一执行流的内核”升级为“支持多线程调度的内核”。

通过本实验，我们旨在深入理解虚拟内存的组织方式、内核线程的创建、执行、切换与调度的全过程，为后续实现用户进程和系统调用奠定坚实的理论与实践基础。

## 2. 小组成员分工


| 姓名 | 学号 | 核心分工 | 具体职责 |
| :--- | :--- | :--- | :--- |
| **查许琴** | 2314076 | **核心编码与调试 (练习1, 练习3)** | <ul><li>负责 `alloc_proc` 函数的实现，完成进程控制块的初始化。</li><li>负责 `proc_run` 函数的编写，实现进程上下文切换的核心逻辑。</li><li>参与整体代码的编译、调试和问题排查。</li></ul> |
| **刘璇** | 2313255 | **核心编码与文档整理 (练习2)** | <ul><li>负责 `do_fork` 函数的实现，完成内核线程资源的分配和状态复制。</li><li>整理并撰写练习1-3的设计实现过程和问题回答部分的初稿。</li><li>负责对 `get_pid` 的唯一性进行分析和总结。</li></ul> |
| **陈翔** | 2314035 | **理论研究与报告整合** | <ul><li>深入研究 `local_intr_save` 的实现原理和 `get_pte` 函数的设计哲学，完成扩展练习部分的解答。</li><li>负责梳理实验中的重要知识点，并与操作系统原理进行对比分析。</li><li>整合所有成员的工作，完成实验报告的最终撰写、排版与审核。</li></ul> |


## 3. 重要知识点梳理

### 3.1. 实验知识点与OS原理对应分析

| 实验知识点 | OS原理对应知识点 | 含义、关系与差异理解 |
| :--- | :--- | :--- |
| **`proc_struct`** | **进程控制块 (PCB)** | **含义**: PCB是操作系统中用于描述和管理一个进程所需全部信息的数据结构。<br>**关系**: `proc_struct` 就是 ucore 中对 PCB 的具体实现，包含了进程状态、ID、内存映射 (`pgdir`)、执行现场 (`context`, `tf`)等关键信息。<br>**差异**: 本实验中的 `proc_struct` 主要用于内核线程，其 `mm` 字段为空，且所有线程共享内核地址空间，这比通用操作系统中描述用户进程的 PCB 要简化。 |
| **`context` 与 `tf`** | **进程上下文 (Process Context)** | **含义**: 进程上下文是指进程在执行过程中的某一时刻，CPU寄存器和程序计数器的内容。<br>**关系**: `context` 和 `tf` 共同构成了 ucore 中的进程上下文。`tf` (Trapframe) 对应**中断上下文**，在特权级切换时由硬件或中断入口代码自动保存，内容全面。`context` 对应**调度上下文**，在 `switch_to` 中由软件主动保存，内容精简（仅被调用者保存寄存器），旨在优化切换效率。<br>**差异**: 实验中将上下文拆分为两部分，是对不同切换场景的精细化处理，体现了理论在实践中的优化。 |
| **`switch_to` 函数** | **上下文切换 (Context Switch)** | **含义**: 指CPU从一个正在运行的进程切换到另一个就绪态进程的过程，包括保存当前进程状态和加载新进程状态。<br>**关系**: `switch_to` 是上下文切换在 ucore 中的底层汇编实现。它原子性地完成了寄存器级别的状态交换。<br>**差异**: 无显著差异，`switch_to` 是对上下文切换原理的直接代码翻译。 |
| **`schedule` 函数** | **进程调度器 (Scheduler)** | **含义**: 调度器是操作系统中负责根据特定算法（如FIFO, Round-Robin）从就绪队列中选择下一个要执行的进程的模块。<br>**关系**: `schedule` 函数实现了 ucore 中一个简单的 FIFO/Round-Robin 调度器。它遍历 `proc_list` 寻找下一个 `RUNNABLE` 的进程。<br>**差异**: 本实验的调度器是非抢占式的，调度点固定（仅在 `cpu_idle` 中主动调用），比现代操作系统中复杂的抢占式、优先级调度器要简单得多。 |
| **`do_fork` 函数** | **进程创建 (Process Creation)** | **含义**: 操作系统创建新进程的过程，通常通过复制一个现有进程（父进程）来完成。<br>**关系**: `do_fork` 是 ucore 实现进程创建的核心函数，遵循了 `fork` 的基本思想：分配资源、复制状态。<br>**差异**: 本实验的 `do_fork` 用于创建内核线程，不涉及用户地址空间的复制，流程相对简化。 |
| **`get_pte`, `page_insert`** | **内存管理单元(MMU)与页表管理** | **含义**: 操作系统通过配置硬件MMU的页表来实现虚拟地址到物理地址的翻译和内存保护。<br>**关系**: 这些函数是对页表管理的软件实现。`get_pte` 模拟了MMU的页表遍历（page walk）过程，而 `page_insert` 则是修改页表项以建立新的映射。<br>**差异**: 这些是操作系统层面的接口，是对底层硬件行为的封装和管理。 |

### 3.2. OS原理中重要但实验未体现的知识点

1.  **抢占式调度 (Preemptive Scheduling)**: 本实验的调度是非抢占式的，线程除非主动放弃CPU（调用`schedule`），否则会一直运行。现代操作系统大多采用抢占式调度，即通过时钟中断强制剥夺运行时间过长的进程的CPU使用权，以保证系统的公平性和响应性。
2.  **进程间通信 (IPC - Inter-Process Communication)**: 实验中创建的内核线程是独立的，没有涉及它们之间如何协作或交换数据。管道、消息队列、共享内存等IPC机制是多进程系统中不可或缺的部分。
3.  **完整的进程生命周期管理**: 实验中线程执行完任务就退出了，但没有实现父进程对子进程（僵尸进程 `ZOMBIE`）的回收 (`wait` 系统调用)，这在真实的操作系统中会导致资源泄露。
4.  **用户态进程与系统调用**: 本实验只涉及内核线程。用户进程的创建、用户空间与内核空间的隔离、以及通过系统调用陷入内核的完整机制尚未实现。
5.  **同步与互斥 (Synchronization & Mutex)**: 虽然使用了 `local_intr_save` 来保证一小段代码的原子性，但更复杂的同步原语，如信号量 (Semaphore)、互斥锁 (Mutex)，在并发环境下防止竞态条件至关重要，本次实验未涉及。

## 4. 练习解答

### 4.1. 练习0：填写已有实验

已将 Lab3 中实现的时钟中断处理代码，正确填充到 Lab4 的 `kern/trap/trap.c` 文件中的 `interrupt_handler` 函数 `IRQ_S_TIMER` 分支中。

### 4.2. 练习1：分配并初始化一个进程控制块

#### 设计实现过程

`alloc_proc` 函数的目标是分配一个 proc_struct 并初始化所有字段。

我们的实现过程主要是，对 `proc_struct` 的所有成员变量进行初始化：

*   将 `pid` 设置为-1，表示尚未分配。
*   将 `kstack`, `runs` 等数值型成员设为0。
*   将 `parent`, `mm`, `tf` 等指针成员设为 `NULL`。
*   **关键一步**：使用 `memset` 将 `context` 结构体清零，确保在首次切换时不会加载到随机的寄存器值。
*   对于内核线程，其页目录 `pgdir` 暂时指向内核页目录 `boot_pgdir_pa`，因为所有内核线程共享内核地址空间。
*   使用 `memset` 清空进程名 `name`。

完成后的代码如下：
```c
// kern/process/proc.c :: alloc_proc()
proc->state = PROC_UNINIT;      // 设置为未初始化状态
proc->pid = -1;                 // 尚未分配PID
proc->runs = 0;                 // 运行次数清零
proc->kstack = 0;               // 内核栈尚未分配
proc->need_resched = 0;         // 默认不需要调度
proc->parent = NULL;            // 尚未指定父进程
proc->mm = NULL;                // 内核线程不独立管理用户内存
memset(&(proc->context), 0, sizeof(struct context)); // 清空上下文
proc->tf = NULL;                // 中断帧指针为空
proc->pgdir = boot_pgdir_pa;    // 内核线程共享内核页表
proc->flags = 0;                // 标志位清零
memset(proc->name, 0, PROC_NAME_LEN + 1); // 进程名清空
```

#### 问题回答

**请说明proc_struct中 `struct context context` 和 `struct trapframe *tf` 成员变量含义和在本实验中的作用是啥？**

这两个成员都用于保存进程的执行现场（寄存器状态），但它们服务的场景和机制完全不同，是理解操作系统上下文切换的精髓：

1.  **`struct context context` (调度上下文)**：
    *   **含义**：它是一个**精简的**执行现场存档，仅包含那些在函数调用中需要被调用者保存 (callee-saved) 的寄存器，如 `ra` (返回地址), `sp` (栈指针), 以及 `s0-s11`。
    *   **作用**：专门用于**协作式进程切换**。在 `switch_to` 函数中，内核**主动地**保存当前进程的 `context`，并加载下一个进程的 `context`。这是一种软件层面的、为提高效率而优化的状态保存。

2.  **`struct trapframe *tf` (中断上下文)**：
    *   **含义**：它是一个**完整的**执行现场存档，保存了进程在被中断或陷入内核时几乎所有的CPU寄存器状态，包括通用寄存器、程序计数器(`epc`)、状态寄存器(`status`)等。`tf` 是一个指向保存在内核栈上中断帧的指针。
    *   **作用**：
        *   **中断/异常处理**：当中断发生时，硬件或内核入口代码**自动地**保存现场到中断帧，以便处理完毕后能精确返回。
        *   **新线程初始化**：在本实验中，我们巧妙地利用它来**“伪造”**一个新线程的初始状态。在 `kernel_thread` 中，我们手动构建了一个 `trapframe`，将新线程要执行的函数地址和参数填入其中，从而引导新线程在第一次被调度时，能够正确地启动。

### 4.3. 练习2：为新创建的内核线程分配资源

#### 设计实现过程

`do_fork` 函数是创建新进程（本实验中是内核线程）的核心，它负责统筹所有资源的分配和状态的复制。我们的实现严格遵循了“资源分配 -> 状态设置 -> 加入调度”的流程，并考虑了错误处理时的资源回收。

实现步骤如下：
1.  **分配PCB**: 调用 `alloc_proc()` 获取一个已初始化的 `proc_struct`。若失败则直接退出。
2.  **设置父子关系**: 将新进程的 `parent` 指针指向当前运行的进程 `current`。
3.  **分配内核栈**: 调用 `setup_kstack()` 为新进程分配一块独立的内核栈空间。若失败，需回滚已分配的 `proc_struct`。
4.  **复制内存管理**: 调用 `copy_mm()`。对于本实验的纯内核线程，这一步仅会断言当前进程 `mm` 为空然后返回成功，真正的页表指针在 `alloc_proc()` 中已经预设为 `boot_pgdir_pa`。若失败，则回滚内核栈和PCB。
5.  **设置启动状态**: 调用 `copy_thread()`，这是最关键的一步。它将 `kernel_thread` 准备好的临时 `trapframe` 复制到新进程内核栈的顶部，并精心构造 `context`，特别是将返回地址 `ra` 指向 `forkret`，为新线程的“冷启动”做好准备。
6.  **赋予唯一身份并加入队列**: 在**关闭中断**的保护下，为新进程分配一个唯一的PID (`get_pid()`)，并将其加入到全局的 `proc_list` 和哈希表中。关中断确保了这一系列操作的原子性。
7.  **唤醒进程**: 调用 `wakeup_proc()` 将新进程的状态从 `PROC_EMBRYO` 置为 `PROC_RUNNABLE`，使其能够被调度器发现。
8.  **返回PID**: 向父进程返回新创建子进程的PID。

```c
// kern/process/proc.c :: do_fork() (伪代码)
int do_fork(...) {
    // 1. 调用alloc_proc分配proc_struct
    proc = alloc_proc();
    if (proc == NULL) return -E_NO_FREE_PROC;

    // 2. 设置父进程
    proc->parent = current;

    // 3. 分配内核栈
    if (setup_kstack(proc) != 0) { /* 回滚并返回错误 */ }

    // 4. 复制内存管理信息
    if (copy_mm(clone_flags, proc) != 0) { /* 回滚并返回错误 */ }

    // 5. 复制线程状态，设置启动点
    copy_thread(proc, stack, tf);

    // 6. (关中断) 分配PID，加入进程列表和哈希表
    local_intr_save(intr_flag);
    proc->pid = get_pid();
    hash_proc(proc);
    list_add(&proc_list, &(proc->list_link));
    nr_process++;
    local_intr_restore(intr_flag);

    // 7. 唤醒新进程
    wakeup_proc(proc);

    // 8. 返回PID
    return proc->pid;
}
```

#### 问题回答

**请说明ucore是否做到给每个新fork的线程一个唯一的id?请说明你的分析和理由。**

是的,ucore 通过 `get_pid()` 函数的设计和调用时的保护机制,**确保了**为每个新 fork 的线程分配一个唯一的ID。

理由如下:
1.  **线性递增与循环使用**: `get_pid()` 内部使用一个静态变量 `last_pid` 来记录上一次分配的ID。每次分配时,它会自增 `last_pid`,当达到 `MAX_PID` 时会回绕到 1(PID=0 保留给 `idleproc`),实现循环使用。
2.  **优化的冲突检测机制**: `get_pid()` 采用了一个高效的算法来确保唯一性:
    *   维护一个 `next_safe` 变量,表示下一个已知会冲突的PID上界。当 `last_pid < next_safe` 时,可以直接返回 `last_pid` 而无需扫描。
    *   当 `last_pid >= next_safe` 时,才遍历整个 `proc_list`,检查候选 `last_pid` 是否被占用:
        *   如果发现冲突(`proc->pid == last_pid`),则递增 `last_pid` 并根据需要重新扫描。
        *   同时更新 `next_safe` 为遇到的下一个最小的已占用PID,以优化后续分配。
    *   这种设计大幅减少了不必要的链表遍历,提高了分配效率。
3.  **原子性保证**: `do_fork` 在调用 `get_pid()` 以及后续将新进程加入 `proc_list` 的整个过程中,使用了 `local_intr_save()` 和 `local_intr_restore()` 来**关闭和恢复中断**。这形成了一个临界区,防止了在单核CPU上因中断而导致的并发问题,确保了"分配PID"和"注册该PID"这两个步骤之间不会被其他进程创建流程打断,从而避免了两个进程获取到相同PID的竞态条件。

综上,通过"递增+安全区间优化"的高效算法和中断屏蔽的并发保护,ucore 可靠地实现了PID的唯一性分配。

### 4.4. 练习3：编写 proc_run 函数

#### 设计实现过程

`proc_run` 函数是进程调度的执行者，它负责完成从当前进程 `current` 到目标进程 `proc` 的实际切换。

实现步骤如下：
1.  **自检**: 首先检查 `proc` 是否就是 `current`。如果是，则无需切换，直接返回。
2.  **保护临界区**: 调用 `local_intr_save()` 保存当前中断状态并禁用中断。上下文切换是内核中最敏感的操作之一，必须保证其原子性。
3.  **更新当前进程指针**: 将全局的 `current` 指针指向新的目标进程 `proc`。这是逻辑上的切换。
4.  **切换地址空间**: 调用 `lsatp(next->pgdir)`（在RISC-V中即写入`satp`寄存器）。这将CPU的MMU指向新进程的页表，使得后续的指令和数据访问都在新进程的地址空间中进行。
5.  **切换CPU上下文**: 调用 `switch_to(&(prev->context), &(next->context))`。这是物理上的切换。这个汇编函数会保存旧进程的 `context` 并加载新进程的 `context`。**当 `switch_to` 返回时，代码已经运行在新进程的内核栈上，CPU的寄存器也已是新进程的状态。**
6.  **恢复中断状态**: `switch_to` 返回后（此时已是新进程在执行），调用 `local_intr_restore()` 恢复之前保存的中断状态。

```c
// kern/schedule/sched.c :: proc_run()
void proc_run(struct proc_struct *proc) {
    if (proc != current) {
        bool intr_flag;
        struct proc_struct *prev = current, *next = proc;
        
        // 1. 禁用中断，进入临界区
        local_intr_save(intr_flag);
        {
            // 2. 更新当前进程
            current = proc;
            
            // 3. 切换页表（地址空间）
            lsatp(next->pgdir);
            
            // 4. 切换CPU寄存器（上下文）
            switch_to(&(prev->context), &(next->context));
        }
        // 5. 恢复中断
        local_intr_restore(intr_flag);
    }
}
```

#### 问题回答

**在本实验的执行过程中，创建且运行了几个内核线程？**

在本实验的执行过程中，总共**创建并运行了2个内核线程**。

1.  **`idleproc` (PID=0)**: 这是系统在 `proc_init()` 中创建的第一个内核线程。它并非通过 `do_fork` 创建，而是将内核初始化后的主执行流“包装”而成。它的任务是执行 `cpu_idle()`，在系统空闲时让出CPU。它**运行了**，因为它执行了 `cpu_idle` 并最终调用 `schedule()`。
2.  **`initproc` (PID=1)**: 这是由 `idleproc` 调用 `kernel_thread()` 函数创建的第一个“真正”的内核线程。`schedule()` 函数会选择它作为下一个运行的进程。它的任务是执行 `init_main` 函数，依次打印“这是 initproc...”以及 `To U: "Hello world!!"`、`To U: "en.., Bye, Bye. :)"` 等信息。从实验输出可以看到这些内容，证明 `initproc` 也**运行了**。

因此，实验成功创建了 `idleproc` 和 `initproc` 两个内核线程，并且通过调度机制，两者都获得了CPU执行时间。

## 5. 扩展练习 (Challenge)

### 5.1. `local_intr_save` 开关中断的实现原理

`local_intr_save(intr_flag); ... local_intr_restore(intr_flag);` 这一对宏通过操作RISC-V的 `sstatus` 寄存器，实现了一种**可安全嵌套的**中断开关机制。

**实现原理**:
1.  **`local_intr_save(intr_flag)`**:
    *   **保存状态**: 首先，它读取 `sstatus` 寄存器，并检查其中的 `SIE` (Supervisor Interrupt Enable) 位。如果 `SIE` 为1，表示中断当前是开启的，于是将 `intr_flag` 设为真并调用 `intr_disable()` 关闭中断；如果 `SIE` 为0，则 `intr_flag` 为假且不会重复执行关闭操作。这一步**既保存了进入临界区前的中断状态，也避免了多余的关中断指令**。

2.  **`local_intr_restore(intr_flag)`**:
    *   **恢复状态**: 它检查传入的 `intr_flag`。如果 `intr_flag` 为真（意味着进入前中断是开启的），它就调用 `intr_enable()`，重新设置 `sstatus` 的 `SIE` 位，**恢复中断**。如果 `intr_flag` 为假，它什么也不做，保持中断关闭。

**关键优势**: 这种“保存-操作-恢复”的模式，完美解决了中断开关嵌套的问题。内层的 `local_intr_save` 会关闭中断，但外层的 `local_intr_restore` 会根据其保存的原始状态（中断开启）来恢复中断，不会被内层的操作干扰，保证了逻辑的正确性。

### 5.2. `get_pte` 函数设计分析

**`get_pte()` 函数中有两段形式类似的代码，为什么如此相像？**

`get_pte` 中处理一级页目录 (`pdep1`) 和二级页目录 (`pdep0`) 的代码段高度相似，这是由**多级页表的递归/层次结构**所决定的。

1.  **统一的遍历逻辑**: 无论是哪一级页表，地址翻译的“一步”都遵循相同的逻辑：
    a.  从虚拟地址中提取出当前级别的索引 (`PDX1`, `PDX0`, `PTX`)。
    b.  使用索引在当前页表中找到对应的页表项 (PTE/PDE)。
    c.  检查该项的有效位 (`PTE_V`)。
    d.  如果有效，从中提取下一级页表的物理地址，并继续遍历。
    e.  如果无效，则需要根据 `create` 标志决定是中止还是分配新页作为下一级页表。

2.  **代码体现递归性**: `get_pte` 中的两段相似代码，正是对 Sv39 三级页表（两级页目录 + 一级页表）遍历过程前两步的直接实现。每一段代码都在执行上述的统一逻辑。如果要支持 Sv48（四级页表），只需再复制并调整索引宏，增加第三段类似的代码即可。这种结构清晰地反映了页表设计的内在规律。

**将查找和分配合并在一个函数里好吗？有没有必要拆开？**

这是一个典型的软件设计权衡问题 (trade-off)。

**当前合并设计的优点**:
*   **便利性**: 对于 `page_insert` 这类总是需要“找到或创建”的调用者来说，一个函数接口非常方便。
*   **代码复用**: 查找的遍历逻辑是创建的前提，合并可以避免代码重复。

**当前合并设计的缺点**:
*   **违反单一职责原则 (SRP)**: 一个函数同时承担了“查询”和“修改（创建）”两个职责，使得函数意图不够清晰。
*   **接口不纯粹**: 对于只想检查映射是否存在而绝不希望产生副作用（如内存分配）的场景，调用者必须小心地将 `create` 设为 `false`。

**更优的设计方案**:
在更大型、更复杂的内核中，**将功能拆分是更推荐的做法**：
1.  `pte_t *find_pte(pgdir, la)`: 一个纯查询函数，只查找，不存在则返回 `NULL`，无任何副作用。
2.  `pte_t *create_pte_path(pgdir, la)`: 一个修改函数，确保 `la` 的完整页表路径存在，不存在则分配创建。

**结论**: ucore 作为教学内核，当前的合并设计通过 `create` 标志位提供了一定的灵活性，是可接受的。但从软件工程的最佳实践来看，拆分为两个职责单一的函数会使得接口更清晰、使用更安全、代码更易于维护。

## 6. 实验总结与体会

本次实验是一次跨越式的学习体验，我们亲手为 ucore 内核赋予了“并发”的灵魂。通过实现进程控制块的初始化、内核线程的创建和上下文切换，我们对操作系统如何虚拟化CPU这一核心概念有了前所未有的深刻理解。

在 `alloc_proc` 和 `do_fork` 的编写中，我们体会到了内核对资源管理的严谨性，任何一步分配失败都必须伴随着细致的错误处理和资源回收。而在 `proc_run` 和 `switch_to` 的实现中，我们更是深入到了操作系统的心脏地带，亲眼见证了CPU控制权在不同执行流之间的交接。`context` 和 `trapframe` 的区别与联系，曾是理论学习中的一个难点，但在编码实践中，它们的作用和使用场景变得无比清晰。

扩展练习引导我们思考了更深层次的设计哲学，无论是中断开关的嵌套安全，还是 `get_pte` 函数的职责划分，都让我们认识到，优秀的内核代码不仅要实现功能，更要追求健壮、清晰和可维护性。

