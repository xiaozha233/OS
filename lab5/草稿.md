# Lab5 实验报告：用户进程管理

## 小组信息

**小组成员及分工：**

| 学号 | 姓名 | 分工 |
|------|------|------|
| 2314076 | 查许琴 | 练习2（copy_range函数实现）、整体测试与调试 |
| 2314035 | 陈翔 | 练习1（load_icode函数实现）、分支任务（gdb调试） |
| 2313255 | 刘璇 | 练习3（源代码分析）、实验报告整理 |

---

## 实验目的

- 了解第一个用户进程创建过程
- 了解系统调用框架的实现机制
- 了解ucore如何实现系统调用sys_fork/sys_exec/sys_exit/sys_wait来进行进程管理

---

## 练习1：加载应用程序并执行


## 练习2：父进程复制自己的内存空间给子进程

## 练习3：阅读分析源代码

### fork/exec/wait/exit执行流程分析


### 用户态与内核态交错执行机制

## 分支任务：GDB调试系统调用

### 调试准备

#### 启动 QEMU 并连接 GDB（客体侧）

本仓库的 `Makefile` 已提供调试目标：

1) （可选）选择要跑的用户程序：

```bash
make build-exit
```

2) 启动 QEMU 并打开 gdbstub（会停在第一条指令，等待连接）：

```bash
make debug
```

3) 另开一个终端连接客体 GDB：

```bash
make gdb
```

后续所有 `gdb` 命令均在这份“客体 GDB”（`target remote localhost:1234`）里执行。

#### 加载用户程序符号表

由于用户程序采用“Link-in-Kernel”方式编译进内核镜像，内核符号表里默认不包含用户 ELF 的调试信息。要在 GDB 里看到用户态源码/符号，需要手动加载对应的用户 ELF（例如 `exit` 对应 `obj/__user_exit.out`）。

注意：用户程序的链接地址由 `tools/user.ld` 指定（本仓库为 `0x800020`）。如果 GDB 不能自动识别 ELF 段地址，可在 `add-symbol-file` 后显式给出 `.text` 起始地址。

```gdb
(gdb) add-symbol-file obj/__user_exit.out
add symbol table from file "obj/__user_exit.out"
(y or n) y
Reading symbols from obj/__user_exit.out...

# 备选（仅当上面方式无法正确对应地址时）：
# (gdb) add-symbol-file obj/__user_exit.out 0x800020
```


### 调试结果总结

### 调试 ecall：只用“客体 GDB”也能验证关键机制（推荐）

#### 1. 在用户态 `syscall()` 处设置断点

```gdb
(gdb) break syscall
(gdb) continue
```

#### 2. 单步执行到 `ecall` 指令

使用`si`（step instruction）单步执行汇编指令，并使用`x/7i $pc`查看接下来的指令：

```gdb
(gdb) si
1: x/7i $pc
=> 0x800104 <syscall+44>:       ecall
   0x800108 <syscall+48>:       sd      a0,28(sp)
   0x80010c <syscall+52>:       lw      a0,28(sp)
   ...
```

此时可以顺便确认寄存器约定是否符合本仓库实现：

- 系统调用号在 `a0`
- 参数在 `a1`~`a5`
- 返回值最终写回 `a0`

```gdb
(gdb) info reg a0 a1 a2 a3 a4 a5
```

#### 3. 观察陷入内核后的入口与 CSR（可复现证据）

在同一个 GDB（连接 `target remote localhost:1234`）里，给内核入口下断点即可观察“ecall 之后 CPU 跳到了哪里”。

```gdb
(gdb) break __alltraps
(gdb) continue
```

命中后重点看：

```gdb
(gdb) info reg pc sp sepc scause stval sstatus stvec
```

你应该能看到：

- `scause` 对应用户态 ecall（`CAUSE_USER_ECALL`）
- `sepc` 指向触发 ecall 的那条指令地址
- `pc` 已经跳到 `stvec` 指定的异常入口（也就是 `__alltraps` 附近）

### 调试 sret：观察返回用户态前后的 PC/特权级相关位

#### 1. 在返回用户态前设置断点

系统调用处理完成后，会通过`__trapret`返回用户态。在`sret`指令前设置断点：

```gdb
(ucore GDB)
(gdb) break *__trapret  # 或者 kern/trap/trapentry.S 中sret的位置
(gdb) continue

```

接下来用 `si` 单步执行到 `sret` 前后，对比 `pc/sepc/sstatus`：

```gdb
(gdb) x/5i $pc
(gdb) info reg sepc sstatus
(gdb) si   # 执行 sret
(gdb) info reg pc sstatus
```

如果返回用户态，预期现象是：

- `pc` 跳到 `sepc`（用户态下一条要执行的指令）
- `sstatus.SPP` 对应“返回到 U-mode”（本仓库在 `load_icode` 中确保 SPP 清零）
- `sstatus.SIE` 在返回后会根据 `SPIE` 被恢复

### （可选）在 QEMU 侧做第二重调试：调试“模拟器如何处理 ecall/sret”

这一部分只在你**有带调试符号的 QEMU**（或自行编译了 `--enable-debug` 且未 strip）时才可复现：否则 host 侧 GDB 往往无法按函数名下断点。

思路是：

1. 仍然用 `make debug` 启动 QEMU（客体 CPU 在 `-S` 下暂停）。
2. 再开一个 host 侧 GDB，attach 到 QEMU 进程（这是“第二重 GDB”）。
3. 在 QEMU 的 RISC-V 异常入口/特权指令 helper 处下断点（函数名随 QEMU 版本变化，可用 `info functions riscv` 辅助查找）。
4. 在客体 GDB 中执行到 `ecall/sret`，host GDB 即可捕捉到 QEMU 内部的处理。

为了避免“不同版本 QEMU 的内部实现差异”导致报告不可复现，本报告不再粘贴 QEMU 内部伪源码，而是以“可观察到的现象（CSR/PC/调用栈）”作为证据。

在 host 侧你通常能看到 QEMU 走到 TCG/翻译块执行路径（如 `cpu_exec`/`tb_gen_code`/`tcg_gen_code` 等），并在遇到特权指令或异常时调用 RISC-V 相关 helper。

---

### TCG (Tiny Code Generator) 翻译机制（概念补充）

#### 什么是TCG

QEMU使用TCG进行指令翻译：
- **动态二进制翻译**：将客户机指令（如RISC-V）翻译为主机指令（如x86）
- **翻译块（TB）**：以基本块为单位进行翻译和缓存
- **JIT编译**：第一次执行时翻译，后续直接执行翻译后的代码

#### 调试中观察到的TCG过程

在lab2的地址翻译调试中，我们实际上也遇到了TCG：

```gdb
# 在QEMU中设置断点时
(gdb) break get_physical_address
Breakpoint 1 at ...

# 执行时可以看到：
(gdb) bt
#0  get_physical_address ()
#1  riscv_cpu_tlb_fill ()
#2  tcg_gen_code ()          # ← TCG代码生成
#3  tb_gen_code ()           # ← 翻译块生成
#4  cpu_exec ()
```

**TCG翻译流程**：

```
1. 取指令（Fetch）
   ├─> 从客户机PC读取RISC-V指令
   └─> 如ecall、sret、ld等

2. 翻译（Translate）
   ├─> 将RISC-V指令转换为TCG中间表示（IR）
   ├─> TCG IR是与平台无关的操作序列
   └─> 例如：ecall → 调用helper_ecall函数

3. 代码生成（Generate）
   ├─> 将TCG IR转换为主机机器码（如x86）
   └─> 缓存到翻译块（Translation Block）

4. 执行（Execute）
   └─> 直接执行主机机器码（高性能）

5. 特殊情况处理
   ├─> 特权指令（ecall/sret）→ 调用helper函数
   ├─> 内存访问 → 触发TLB查找
   └─> 异常 → 退出翻译块，进入异常处理
```

#### TCG与地址翻译的关系

在lab2调试地址翻译时：

```
用户程序访问虚拟地址 va
  ↓
TCG翻译内存访问指令（如ld）
  ↓
生成主机代码：调用TLB查找
  ↓
TLB miss → get_physical_address()  ← 我们在这里设置断点
  ↓
查页表，返回物理地址 pa
  ↓
完成内存访问
```

### 调试过程中的有趣发现

#### 1. sscratch寄存器的巧妙用法

在`trapentry.S`中，sscratch用于判断来自用户态还是内核态：

```asm
csrrw sp, sscratch, sp  # 交换sp和sscratch
bnez sp, _save_context  # sp非0说明来自用户态
```

**为什么这样设计？**
- 用户态时：sscratch保存内核栈指针，交换后sp指向内核栈
- 内核态时：sscratch为0，交换后sp变为0，需要恢复

这是RISC-V架构的经典技巧！

#### 2. QEMU模拟硬件的精细度

如果 host 侧 QEMU 带符号并可 attach，确实能观察到它在处理异常/特权指令时会更新“客户机的 CSR 状态”（如 `sepc/scause/sstatus`）并跳转到 `stvec` 指定入口。由于不同版本 QEMU 内部实现细节差异较大（函数名/数据结构会变化），这里以“现象可验证”为准，不再粘贴特定版本的内部代码片段。

#### 3. 断点的本质

在QEMU GDB调试时，我们设置的断点实际上是在**主机代码**中：

```
源码：RISC-V ecall指令
  ↓ TCG翻译
主机码：call helper_ecall (x86指令)
  ↑
GDB断点实际打在这里！
```

这解释了为什么需要attach到QEMU进程才能观察指令处理。

### 使用大模型解决的问题记录


## 实验总结



---

## 测试结果


---

## 扩展练习 Challenge：用户程序何时被预先加载到内存？与常见 OS 有何区别？


