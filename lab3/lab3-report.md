  
  

# 实验三 - 实验报告

  

| 姓名 | 学号 | 分工 |
| :--- | :--- | :--- |
| 陈翔 | 2314035 | 练习1编码与报告撰写、知识点总结 |
| 查许琴 | 2314076 | 扩展练习 Challenge1 & 2 回答与报告撰写 |
| 刘璇 | 2313255 | 扩展练习 Challenge3 编码与报告撰写、整体报告整理与校对 |

  
## 实验目的

本次实验的核心是理解和掌握操作系统的中断处理机制。操作系统作为计算机系统的核心管理者，必须能够响应各种突发事件，例如硬件设备请求（中断）或程序执行错误（异常）。当中断或异常发生时，CPU会暂停当前任务，跳转到操作系统预设的处理程序，待处理完成后再返回原任务继续执行。

通过本次实验，我们学习了：

- RISC-V 架构的中断与异常处理机制，包括相关的特权级和控制状态寄存器（CSRs）。

- 中断发生前后，如何通过汇编代码实现上下文环境（即寄存器状态）的保存与恢复。

- 如何编写中断处理程序，并成功处理了断点（breakpoint）和时钟（timer）这两种基本的中断类型，验证了中断系统的正确性。

  

## 实验内容

  

本次实验主要围绕中断处理机制的实现展开。我们首先学习了RISC-V架构的中断处理原理、相关寄存器（如 `stvec`, `sepc`, `scause` 等）及特权指令。接着，我们深入分析了上下文保存与恢复的实现细节，理解了如何通过一个`trapframe`结构体和一段精巧的汇编代码`trapentry.S`来完成这一关键过程。最后，通过完成三个练习，我们动手实现了时钟中断处理和两种基本的异常处理，从而验证了我们所构建的中断系统的正确性和有效性。

  

## 练习与挑战

  

### 练习1：完善中断处理 （编程）

  

#### 1. 实现过程

  

本次练习的目标是完善位于 `kern/trap/trap.c` 文件中的 `interrupt_handler` 函数，使其能够正确处理S模式下的时钟中断（`IRQ_S_TIMER`）。

  

具体实现步骤如下：

  

1.  **定位代码位置**：在 `interrupt_handler` 函数中找到 `case IRQ_S_TIMER:` 分支。

2.  **设置下一次时钟中断**：在处理当前中断时，必须立即安排下一次中断的触发时间。我们通过调用 `clock_set_next_event()` 函数来实现。该函数内部会通过SBI调用 `sbi_set_timer()`，将下一次中断时间设置为当前时间加上一个固定的时间间隔（`timebase`）。

3.  **更新时钟计数器**：定义一个全局静态变量 `ticks`（位于 `kern/driver/clock.c`），每次进入时钟中断处理程序时，将其值加一。

4.  **周期性打印信息**：判断 `ticks` 是否达到 `TICK_NUM`（定义为100）的倍数。如果是，则调用 `print_ticks()` 函数，在屏幕上打印 "100 ticks"。

5.  **实现关机功能**：为了在打印10行后自动关机，我们在 `print_ticks()` 函数内部（或 `interrupt_handler` 中）定义一个静态计数器 `num`。每当 `print_ticks()` 被调用时，`num` 加一。当 `num` 达到10时，调用 `sbi_shutdown()` 函数关闭系统。

  

#### 2. 定时器中断处理流程

  

一次完整的时钟中断处理流程如下：

  

1.  **中断触发**：当 `time` 寄存器的值达到 OpenSBI 中设置的下一次事件时间点时，硬件会触发一个S模式的时钟中断。

2.  **硬件响应**：CPU硬件自动执行以下操作：

    *   将当前PC值（即被打断指令的地址）保存到 `sepc` 寄存器。

    *   在 `scause` 寄存器中记录中断原因（S模式时钟中断）。

    *   将 `sstatus` 寄存器中的 `SIE` 位（中断使能）保存到 `SPIE` 位，然后清除 `SIE` 位，以屏蔽后续的中断。

    *   将特权级从U模式或S模式切换到S模式，并将之前的特权级记录在 `SPP` 位。

    *   将PC设置为 `stvec` 寄存器指向的地址，即我们的中断入口点 `__alltraps`。

3.  **上下文保存**：执行 `kern/trap/trapentry.S` 中的 `__alltraps` 代码。

    *   `SAVE_ALL` 宏被调用，将所有通用寄存器以及 `sepc`, `scause`, `sstatus` 等CSR的值压入当前内核栈中，形成一个 `trapframe` 结构体。

4.  **进入C处理函数**：汇编代码将当前栈顶指针（即 `trapframe` 的地址）存入 `a0` 寄存器，作为参数，然后通过 `jal trap` 指令调用C语言实现的 `trap` 函数。

5.  **中断分发**：`trap` 函数调用 `trap_dispatch`，根据 `tf->cause` 的最高位判断是中断还是异常。对于时钟中断，它会调用 `interrupt_handler`。

6.  **时钟中断处理**：`interrupt_handler` 根据 `tf->cause` 的具体值，进入 `IRQ_S_TIMER` 分支，执行我们在练习1中编写的逻辑：调用 `clock_set_next_event()`、增加 `ticks` 计数器、并根据条件打印信息或关机。

7.  **返回汇编代码**：`trap` 函数执行完毕后返回到 `trapentry.S`。

8.  **上下文恢复**：执行 `__trapret` 处的代码。

    *   `RESTORE_ALL` 宏被调用，从栈上的 `trapframe` 中恢复所有通用寄存器以及 `sepc` 和 `sstatus` 的值。

9.  **中断返回**：最后执行 `sret` 特权指令。硬件会自动将 `sepc` 的值恢复到PC，并将 `sstatus` 的 `SPIE` 位恢复到 `SIE` 位，从而恢复到中断前的特权级和中断使能状态，程序从被中断处继续执行。

  

#### 3. 代码实现

  

以下是 `kern/trap/trap.c` 中 `interrupt_handler` 函数的修改部分：

  

```c

// kern/trap/trap.c

  

// 全局的ticks计数器，虽然定义在clock.c，但在这里被使用

extern volatile size_t ticks;

  

void interrupt_handler(struct trapframe *tf) {

    intptr_t cause = (tf->cause << 1) >> 1;

    switch (cause) {

        // ... 其他 case ...

        case IRQ_S_TIMER:

            // 实验三 练习一 YOUR CODE 2023010001

            clock_set_next_event(); // (1) 设置下一次时钟中断

            ticks++;                // (2) 计数器（ticks）加一

            if (ticks % TICK_NUM == 0) {

                print_ticks();      // (3) 调用打印函数

                // (4) 判断打印次数并关机

                static int print_count = 0;

                print_count++;

                if (print_count >= 10) {

                    sbi_shutdown();

                }

            }

            break;

        // ... 其他 case ...

    }

}

```

  

### 扩展练习 Challenge1：描述与理解中断流程

  

1.  **描述ucore中处理中断异常的流程（从异常的产生开始）**

  

    ucore处理中断/异常的流程是一个软硬件紧密结合的过程，具体如下：

    1.  **事件产生**：硬件（如时钟、外部设备）或软件（如执行`ecall`、非法指令）触发一个中断或异常事件。

    2.  **硬件陷入 (Trap)**：CPU硬件自动完成一系列操作：

        *   保存当前程序计数器（PC）到`sepc`寄存器。

        *   在`scause`寄存器中设置事件的原因码。

        *   在`stval`寄存器中存入与异常相关的附加信息（如非法指令本身或访存失败的地址）。

        *   屏蔽S模式中断（`sstatus.SIE` -> 0）。

        *   切换到S模式，并将PC跳转到`stvec`寄存器指定的地址，即中断入口点 `__alltraps`。

    3.  **保存上下文 (`__alltraps`)**：

        *   执行`trapentry.S`中的`SAVE_ALL`宏。

        *   在内核栈上分配`trapframe`大小的空间。

        *   将32个通用寄存器、`sstatus`、`sepc`、`scause`等关键CSR的值保存到栈上的`trapframe`结构体中。

    4.  **调用C处理函数**：

        *   将指向`trapframe`的栈指针`sp`移动到`a0`寄存器，作为第一个参数。

        *   使用`jal trap`指令跳转到C语言函数`trap()`。

    5.  **分发与处理 (`trap.c`)**：

        *   `trap()`函数调用`trap_dispatch()`，根据`trapframe`中的`cause`值判断是中断还是异常。

        *   `trap_dispatch()`再将控制权交给`interrupt_handler()`或`exception_handler()`。

        *   具体的处理函数根据`cause`值的具体编码，执行相应的处理逻辑（如时钟中断处理、系统调用服务等）。

    6.  **返回准备 (`trap.c` -> `trapentry.S`)**：C函数处理完毕后返回。

    7.  **恢复上下文 (`__trapret`)**：

        *   执行`RESTORE_ALL`宏。

        *   从栈上的`trapframe`中将之前保存的所有寄存器值加载回对应的寄存器。`sstatus`和`sepc`也被恢复。

    8.  **从中断返回**：

        *   执行`sret`指令。

        *   CPU硬件将`sepc`的值恢复到PC，恢复`sstatus`寄存器（特别是中断使能位`SIE`），并根据`SPP`位返回到中断前的特权级。程序从被中断的地方无缝地继续执行。

  

2.  **`mov a0, sp` 的目的是什么？**

  

    `mov a0, sp`（在我们的代码中写作`move a0, sp`）的目的是**传递参数**。

    根据RISC-V的函数调用规范（Calling Convention），第一个整型或指针参数通过`a0`寄存器传递。在`SAVE_ALL`宏执行完毕后，`sp`（栈指针）正指向刚刚在栈上构建的`trapframe`结构体的起始地址。因此，`move a0, sp`这行代码就是将这个`trapframe`的地址存入`a0`寄存器，以便接下来调用的C函数`trap(struct trapframe *tf)`能够接收到这个`trapframe`作为其参数。

  

3.  **`SAVE_ALL`中寄存器保存在栈中的位置是什么确定的？**

  

    寄存器保存在栈中的位置是由 **`struct trapframe` 的结构定义** 和 **`SAVE_ALL` 宏中的硬编码偏移量** 共同确定的。

  

    *   在`kern/trap/trap.h`中，`struct trapframe`定义了所有需要保存的寄存器在内存中连续排列的顺序和布局。

    *   在`kern/trap/trapentry.S`的`SAVE_ALL`宏中，每一条`STORE`指令都使用 `偏移量(sp)` 的寻址方式。例如，`STORE x1, 1*REGBYTES(sp)` 就是将`x1`（`ra`寄存器）保存在从`sp`开始的`1*REGBYTES`（即8字节）偏移处。这些偏移量（`0*REGBYTES`, `1*REGBYTES`, ..., `35*REGBYTES`）与`struct trapframe`中各个字段的顺序是严格对应的。这种方式确保了汇编代码保存的内存布局与C语言的结构体布局完全一致，使得C代码可以正确地访问`trapframe`中的每一个成员。

  

4.  **对于任何中断，`__alltraps` 中都需要保存所有寄存器吗？请说明理由。**

  

    **是，对于一个通用的中断处理入口（如 `__alltraps`），保存所有通用寄存器是必要且最安全的选择。**

  

    理由如下：

    5.  **保护被中断的上下文**：中断可能在任何指令执行后发生，我们无法预知被中断的程序当时正在使用哪些寄存器。被中断的上下文可能是内核代码，也可能是用户代码。

    6.  **遵循C函数调用规范**：中断处理的后续流程会调用C函数（`trap`）。C编译器在生成代码时，会自由使用**调用者保存（caller-saved）**的寄存器（如`t0-t6`, `a0-a7`），并假定**被调用者保存（callee-saved）**的寄存器（如`s0-s11`）在函数返回后保持不变。由于中断处理函数（`trap`及其调用的函数）本身就是一个C函数，它可能会修改任何调用者保存的寄存器。如果不预先保存它们，当`sret`返回后，被中断程序的执行状态就会被破坏。

    7.  **简化设计**：保存所有寄存器虽然有一定的开销，但极大地简化了中断处理的设计。它创建了一个统一的、可预测的`trapframe`，使得后续的C代码可以无需关心底层细节而安全地执行。若要进行优化（例如，对于某个特定的、简单的中断只保存少量寄存器），就需要为该中断设计一个单独的处理入口和上下文保存/恢复流程，这会增加系统的复杂性。

  

    因此，为了保证正确性和通用性，`__alltraps` 采用了一次性保存所有寄存器的保守策略。

  

### 扩展练习 Challenge2：理解上下文切换机制

  

1.  **在 `trapentry.S` 中汇编代码 `csrw sscratch, sp`；`csrrw s0, sscratch, x0` 实现了什么操作，目的是什么？**

  

    这两条指令是在 `SAVE_ALL` 宏中，配合 `STORE s0, 2*REGBYTES(sp)` 使用的，其核心目的是**在 `trapframe` 中正确地保存中断发生前的原始栈指针 `sp`**。

  

    我们来分解这个过程：

    1.  `csrw sscratch, sp`: 这条指令将当前的栈指针`sp`的值写入`sscratch`这个CSR寄存器中。`sscratch`在这里被用作一个临时“保险箱”，暂存了进入中断处理流程但尚未修改的`sp`值。

    2.  `addi sp, sp, -36 * REGBYTES`: 接下来，栈指针`sp`向下移动，为`trapframe`分配空间。此时，`sp`寄存器的值已经改变了。

    3.  ... (保存除`sp`外的其他寄存器) ...

    4.  `csrrw s0, sscratch, x0`: 这是一条原子读-写-CSR指令。它完成了两件事：

        *   **读**：将 `sscratch` 寄存器的当前值（即步骤1中保存的**原始`sp`**）读取到通用寄存器 `s0` 中。

        *   **写**：将 `x0`（即0）写入 `sscratch` 寄存器。这个清零操作是一个好习惯，可以避免旧数据残留。

    5.  `STORE s0, 2*REGBYTES(sp)`: 最后，将`s0`寄存器中的值（即原始`sp`）保存到`trapframe`中`sp`字段对应的位置。

  

    **总结**：这一系列操作的目的是，在`sp`寄存器因为分配栈帧而被修改后，仍然能够获取并保存中断发生时的**原始`sp`值**。`sscratch`起到了一个临时中转站的作用。

  

2.  **`save all` 里面保存了 `stval`, `scause` 这些CSR，而在 `restore all` 里面却不还原它们？那这样 `store` 的意义何在呢？**

  

    `store`（保存）的意义在于**让软件（C语言中断处理程序）能够读取和分析中断/异常的原因和上下文**，而`restore`（恢复）之所以没有必要，是因为**这些CSR是由硬件在陷入时设置的，并且它们的状态对于被中断的程序来说是透明的、无关的**。

  

    具体原因如下：

    1.  **Store的意义**：当中断或异常发生时，硬件会将事件的原因码写入`scause`，将相关数据（如访存失败的地址）写入`stval`。我们的`trap`函数需要读取`trapframe`中保存的这些值，才能知道发生了什么事（`scause`），以及事件的详细信息（`stval`），从而决定调用哪个处理函数（`interrupt_handler`或`exception_handler`）以及如何处理。没有这些信息，中断处理程序将无法工作。

    2.  **不Restore的原因**：

        *   **硬件管理**：`scause`和`stval`等CSR的值是由硬件在下一次中断或异常发生时自动覆盖的，而不是由软件来维护。它们记录的是“**上一次 trap**”的信息。

        *   **对被中断程序无意义**：被中断的程序并不关心上一次中断的原因。当程序通过`sret`恢复执行时，它应该感觉好像什么都没发生过。恢复`scause`的值对它没有任何帮助。

        *   **只读属性**：从逻辑上讲，这些寄存器对于被中断的程序是“只读”的。它们是被动接收硬件状态的，而不是主动设置的。

  

    总之，保存`scause`和`stval`是为了**向中断处理程序传递信息**，而不恢复它们是因为这些信息是**一次性的、仅供当前中断处理使用的**，恢复它们既无必要也无意义。

  

好的，根据您提供的最新代码，以下是修改和完善后的实验报告。

---

### **扩展练习 Challenge3：完善异常中断（修订版）**

#### 1. 实现过程

本次练习要求我们完善 `kern/trap/trap.c` 中的 `exception_handler` 函数，以捕获并处理两种特定的异常：非法指令 (`Illegal instruction`) 和断点 (`breakpoint`)。

实现步骤如下：

1.  **定位处理位置**：在 `exception_handler` 函数中，找到 `case CAUSE_ILLEGAL_INSTRUCTION:` 和 `case CAUSE_BREAKPOINT:` 这两个分支。

2.  **打印异常信息**：
    *   在各自的 `case` 块中，使用 `cprintf` 函数打印出异常的具体类型（例如，“Illegal instruction” 或 “breakpoint”）以及触发异常的指令地址。
    *   异常指令的地址保存在 `trapframe` 结构体的 `epc` 字段中，因此我们可以通过 `tf->epc` 来获取并打印。

3.  **更新 `epc`**：
    *   异常处理完成后，必须手动更新 `tf->epc` 的值，使其指向下一条指令。如果不这样做，当从异常处理返回时，程序会回到引发异常的指令地址，导致无限循环地触发同一个异常。
    *   对于 **非法指令** (`Illegal instruction`)，为了简化处理，我们假设它是一条4字节长的指令，因此将 `epc` 增加4，即 `tf->epc += 4;`。
    *   对于 **断点** (`breakpoint`)，处理逻辑更为精确。RISC-V的 `ebreak` 指令可能是2字节（在压缩指令集 RVC 中）或4字节（在标准指令集中）。代码通过检查指令的最低两位来区分：
        *   如果指令的最低两位不是 `11`，那么它是一条2字节的压缩指令，此时 `tf->epc += 2;`。
        *   否则，它是一条4字节的标准指令，此时 `tf->epc += 4;`。
    *   这种精确的处理确保了程序总能正确地跳过 `ebreak` 指令，继续执行后续代码。

#### 2. 如何触发异常

为了测试我们完善的异常处理代码，我们需要在内核中手动插入会触发这些异常的指令。这可以通过内联汇编（inline assembly）实现，最佳插入位置是在 `kern/init/init.c` 的 `kern_init` 函数中，并确保在中断系统初始化 (`idt_init()`) 之后。

*   **触发非法指令异常**：可以插入一条无效的指令编码。一个简单的例子是 `.word 0x00000000`，这在RISC-V中通常被识别为非法指令。
*   **触发断点异常**：可以直接插入 `ebreak` 指令。

由于我们的异常处理程序能够正确地跳过异常指令并继续执行，因此在 `ebreak` 指令之后和 `.word 0x00000000` 指令之后的 `cprintf` 语句都应该能被成功执行。

```c
// 在 kern/init/init.c 的 kern_init() 函数中
void kern_init(void) {
    // ...
    idt_init();  // init interrupt descriptor table

    clock_init();   // init clock interrupt
    intr_enable();  // enable irq interrupt

    // ---- 触发异常的测试代码 ----
    // 测试非法指令异常
    cprintf("Testing illegal instruction exception...\n");
    asm volatile (".word 0x00000000");
    cprintf("Illegal instruction test passed.\n");

    // 测试断点异常
    cprintf("Testing breakpoint exception...\n");
    asm volatile ("ebreak");
    cprintf("Breakpoint test passed.\n");
    // -------------------------

    /* do nothing */
    while (1);
}
```

#### 3. 代码实现

以下是 `kern/trap/trap.c` 中 `exception_handler` 函数根据最新代码的最终实现：

```c
// kern/trap/trap.c
void exception_handler(struct trapframe *tf) {
    switch (tf->cause) {
        // ... 其他 case ...
        case CAUSE_ILLEGAL_INSTRUCTION:
            // 非法指令异常处理
            /* 实验三 挑战三 YOUR CODE */
            cprintf("Exception type:Illegal instruction\n");
            cprintf("Illegal instruction caught at 0x%08x\n", tf->epc);
            // 跳过非法指令（假设为4字节指令）
            tf->epc += 4;
            break;

        case CAUSE_BREAKPOINT:
            //断点异常处理
            /* 实验三 挑战三 YOUR CODE */
            cprintf("Exception type: breakpoint\n");
            cprintf("ebreak caught at 0x%08x\n", tf->epc);
            // ebreak 指令在 RV64C（压缩指令集）中是2字节，在标准指令集中是4字节
            // 检查指令长度：如果最低2位不是11，则是压缩指令（2字节）
            uint16_t instr = *(uint16_t*)(tf->epc);
            if ((instr & 0x3) != 0x3) {
                tf->epc += 2;  // 压缩指令
            } else {
                tf->epc += 4;  // 标准指令
            }
            break;
        // ... 其他 case ...
        default:
            print_trapframe(tf);
            break;
    }
}
```

  

## 知识点总结

  

#### 1. 本实验中重要的知识点

  

*   **中断、异常与陷入 (Trap) 的区别**：

    *   **中断 (Interrupt)**：来自外部硬件设备的异步事件，如时钟、I/O设备。

    *   **异常 (Exception)**：在执行指令期间由CPU内部产生的同步事件，如非法指令、缺页。

    *   **陷入 (Trap)**：由程序主动执行的同步事件，用于请求OS服务，如 `ecall` (系统调用)。

*   **RISC-V 特权级**：M（Machine）、S（Supervisor）、U（User）三个特权级，OS内核运行在S模式，用户程序运行在U模式，实现了权限隔离。

*   **中断处理流程**：从硬件触发到`stvec`跳转，再到汇编入口保存上下文，调用C函数处理，最后恢复上下文并`sret`返回的完整闭环。

*   **上下文保存与恢复**：通过`trapframe`结构体和汇编代码，完整地保存和恢复CPU的所有通用寄存器和关键CSR，是实现中断后程序能正确续行的关键。

*   **关键CSR寄存器**：

    *   `stvec`: 存储S模式中断入口地址。

    *   `sepc`: 保存被中断指令的地址。

    *   `scause`: 记录中断/异常的原因。

    *   `stval`: 记录与异常相关的附加信息。

    *   `sstatus`: 控制和记录CPU状态，如中断使能位（SIE）、先前特权级（SPP）。

*   **时钟中断**：利用硬件定时器和SBI调用，实现周期性地打断CPU执行流，是实现任务调度和时间管理的基础。

  

#### 2. 与OS原理的对应关系

  

| 实验知识点 | OS原理知识点 | 关系与理解 |

| :--- | :--- | :--- |

| 中断/异常处理机制 | **中断驱动**、**系统调用接口** | 实验中的中断处理是操作系统“中断驱动”本质的直接体现。`ecall`陷入机制是实现OS“系统调用”的硬件基础，是用户程序获取内核服务的唯一途径。 |

| 上下文保存与恢复 | **进程上下文切换** | 实验中实现的`trapframe`保存与恢复是单线程内的上下文切换。在多进程OS中，这个机制会被扩展，用于在不同进程之间切换，保存的不仅是寄存器，还有页表等更多状态。 |

| 时钟中断 | **进程调度**、**时间片轮转** | 实验中的时钟中断处理是实现抢占式多任务调度的基石。OS利用时钟中断定期获得控制权，检查当前进程的运行时间，决定是否进行进程切换（时间片轮转）。 |

| `intr_disable`/`intr_enable` | **原子操作**、**临界区保护** | 实验中通过开关中断来保护对共享数据（如内存分配链表）的访问，这对应了OS原理中为实现“原子操作”而进入临界区最简单的（也是最强力的）方法：屏蔽中断。 |

| 特权级切换（U->S） | **用户态/内核态隔离** | 实验中从用户态（理论上）到S模式的陷入过程，是OS实现“保护模式”的核心。它确保了用户程序不能直接访问硬件和内核数据，保证了系统的稳定性和安全性。 |

  

#### 3. OS原理中重要但在实验中没有对应上的知识点

  

*   **嵌套中断 (Nested Interrupts)**：本实验中，一旦进入中断处理，`sstatus.SIE`位就被清除，默认屏蔽了所有新的S模式中断。更复杂的OS会支持中断优先级和中断嵌套，允许高优先级中断打断低优先级中断的处理过程。

*   **中断控制器 (PLIC)**：真实的RISC-V系统中，大量外部设备的中断请求是通过平台级中断控制器（Platform-Level Interrupt Controller, PLIC）来管理的。本实验只处理了CPU核心的软件和时钟中断，没有涉及复杂的外部中断源管理。

*   **缺页异常 (Page Fault) 的完整处理**：实验提到了缺页异常，但没有实现其处理。一个完整的缺页处理程序是虚拟内存管理的核心，它需要分配物理页、建立页表映射、换入/换出页面等复杂操作。

*   **用户态中断/信号 (Signals)**：除了内核处理中断外，操作系统还需向用户进程传递某些异步事件（如非法内存访问、Ctrl-C等），这通常通过用户态的信号（Signal）机制实现，其底层也依赖于中断和异常机制。

  

## 总结

  

通过本次实验，我们成功地为ucore内核构建了一套基本但完整的中断处理系统。从硬件的自动陷入，到汇编代码的上下文保存，再到C语言的逻辑处理，最后恢复现场并返回，我们对整个流程有了深刻而具体的理解。

  

我们不仅掌握了RISC-V架构下的中断相关指令和CSR寄存器的用法，还通过编程实践，亲手实现了时钟中断和异常的处理逻辑。这让我们深刻体会到，中断是操作系统能够管理和调度程序的“脉搏”，也是内核与硬件、内核与用户程序交互的桥梁。本次实验为后续学习更复杂的系统调用、进程调度和虚拟内存管理打下了坚实的基础。