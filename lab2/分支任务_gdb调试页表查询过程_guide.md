
分支任务：gdb 调试页表查询过程

在之前，我们已经尝试使用gdb调试了内核启动流程，并且成功的观察到了cpu上电->opensbi初始化->进入到内核的入口点kern_entry->进入到内核c代码入口点kern_init，相信大家应该已经基本掌握gdb的使用方法了那么我们接下来整点俄罗斯套娃式花活，使用gdb调试一下正在调试ucore代码的qemu源码。

前面我们已经完成了物理内存管理，并进入到了虚拟内存访问模式（详见lab2：物理内存与页表）。在虚拟内存访问模式下，当CPU执行一条访存指令（如加载或存储）时，它产生的是一个虚拟地址。这个地址被立即送给内存管理单元（MMU）进行处理。

MMU的首要任务是完成虚拟地址到物理地址的转换。转换的第一步，MMU会查询其内部的转址旁路缓存（TLB）。TLB是一个高速缓存，保存着近期使用过的虚拟页号到物理页帧号的映射。如果当前虚拟地址的页号存在于TLB中（即TLB命中），MMU会立刻将对应的物理页帧号与虚拟地址中的页内偏移量组合，形成物理地址，并完成本次内存访问。

如果TLB中找不到该虚拟页号的映射（即TLB未命中），MMU就必须通过查询当前进程的页表来获取转换关系。在RISC-V的SV39多级页表架构下，这是一个硬件自动完成的查表过程：MMU会依据SATP寄存器中存储的页表基址，结合虚拟地址中的多级索引，逐级访问内存中的页表目录，最终在最后一级页表项中找到目标物理页帧号。

在通过页表成功获得物理页帧号后，MMU会执行两个关键操作：

    使用获得的物理页帧号与页内偏移组合成物理地址，继续完成CPU请求的内存访问。

    将这条新的“虚拟页号-物理页帧号”映射关系存入TLB中。这样，后续对该虚拟地址附近区域的再次访问，就有很高的概率可以直接在TLB中命中，从而极大地提升了地址转换的效率。

以上的内容大家应该在组成原理课上已经听过甚至实现过，大家都清楚的认识到这些功能都是由硬件完成的。而在我们的实验中，ucore运行在qemu通过软件模拟出来的开发板上。这原本可以降低开发的复杂度，但同时也带来了一定的困扰，会让同学们误以为似乎所有的工作都是软件在做。当然软件的实现还有另一个好处，就是我们可以借助源代码分析和调试的工具近距离的观察它。qemu是一个开源的、用软件模拟硬件的模拟器，因此，由硬件完成的代码，就是在qemu中完成的代码。我们本次实验的任务就是尝试观察一下qemu在接收到一个访存指令的时候，是如何一步步的操作的，从而帮助大家进一步理解这个过程。

    重点 我们本次实验有两个目的，其一是让各位同学深入的对比模拟器的实现，充分理解一下整个地址翻译的过程。 而另一个目的则是培养大家使用大模型的能力，希望大家不只是用大模型来做一些常见的工作比如只是用大模型来黑话加密一下自己的报告以及编写代码，而是利用大模型提高自己学习的效率，真正学到知识。 以下的调试流程也是助教在大模型的帮助下学习并整理出来的，大家也可以尝试当作没有这一小节指导书，考虑一下如何在大模型的帮助下从零捋出来一个调试的操作流程。

怎样调试qemu
准备带调试信息的QEMU

    须知

    其实大家应该明白，大模型的使用很简单，只需要描述清楚自己的需求就可以了，前提是你真的知道自己需要什么。在本流程中，附赠一下助教的思路和询问的逻辑，当然，不同的模型的结果也是不一样的，仅供参考。 我对gdb调试有一定了解，我询问的问题是：

        我需要调试一个正在运行我的操作系统内核源码的qemu源码，从而观察一下cpu在虚拟地址空间访问一个虚拟地址是如何查找tlb以及页表的，那么我应该怎么做，是不是需要两个gdb？（附加上指导书lab1中的gdb调试流程以及实验环境搭建的部分）
        （感觉重新编译一个带调试的qemu的流程没理解）我没有理解，你是如何重新编译一个新的带调试信息的qemu的，不需要执行make install吗，那么整个系统中是不是就有了两个qemu（附加了我们搭建环境时的qemu安装流程部分，也就是下面的几行）

还记得我们在环境搭建时安装QEMU的命令吗？

$ wget https://download.qemu.org/qemu-4.1.1.tar.xz
$ tar xvJf qemu-4.1.1.tar.xz
$ cd qemu-4.1.1
$ ./configure --target-list=riscv32-softmmu,riscv64-softmmu
$ make -j
$ sudo make install

这样安装的QEMU虽然能用，但缺少调试信息，就像一本被撕掉了目录和索引的书，GDB无法在其中设置断点或查看源码。我们需要重新编译一个"完整版"的QEMU：

# 进入QEMU源码目录
cd qemu-4.1.1

# 清理之前的编译结果
make distclean

# 重新配置，这次要带上调试选项
./configure --target-list=riscv32-softmmu,riscv64-softmmu --enable-debug

# 重新编译
make -j$(nproc)

重要提示，这段重要提示也是大模型提醒的：编译完成后不要执行sudo make install！我们只是要生成一个带调试信息的QEMU可执行文件(编译完成之后，可以在riscv64-softmmu目录下找到一个qemu-system-riscv64)，而不是替换之前安装在系统里的QEMU。这样，系统里就有两个QEMU：一个是我们日常使用的"正式版"，另一个是我们专门用来调试的"调试版"。

模型使用示例 向一个你使用顺手的大模型提问，我要通过gdb来加断点单步调试qemu-4.1.1，从而理解在qemu中运行的riscv代码的地址转换逻辑，我需要注意哪些细节。你会得到跟下面差不多的信息。

接下来，我们需要修改ucore的Makefile，让它使用我们新编译的调试版QEMU：

# 在Makefile中找到QEMU定义，修改为：
QEMU := /path/to/your/qemu-4.1.1/riscv64-softmmu/qemu-system-riscv64

请将/path/to/your/qemu-4.1.1/替换为你实际的QEMU源码路径。
双重GDB调试策略

    须知

    这段比较关键的问题是：两个gdb的作用是什么，按照我的makefile，调试内核使用的是riscv64专用的gdb，而调试qemu源码的gdb是不是应该是x86的gdb。以及我应该如何操作呢（附上我的makefile）

现在进入有趣的部分：我们将同时使用两个GDB会话，但它们的目标和用法完全不同：

    GDB会话1：使用普通的gdb命令，附加到QEMU进程本身，用于调试QEMU的源码

    GDB会话2：使用riscv64-unknown-elf-gdb，通过QEMU提供的调试接口连接，用于调试运行在模拟器中的ucore内核

这种"双重调试"的架构让我们能够同时观察qemu模拟器和被模拟系统ucore两个层面上的行为，而且这种模式可以让我们先在ucore当中停下来，然后看到那条要执行的riscv指令，然后再观察在qemu中如何完成了对这条指令的解析。
调试步骤详解

我们需要三个终端窗口（多终端配置参考前文GDB调试一节）：

    tips 不难想象，用文字来解释三个终端的运行次序是很麻烦的，我已经能想象到各位因为命令的操作次序晕头转向，你也可以问问大模型来看看到底怎么控制这三个窗口的执行，比如：目前我有了三个终端，但是我没有理解，这三个终端分别是做什么用的，我应该怎么执行这个流程，先执行哪一个，这是在做什么，给我解释的详细一点（你甚至可以把这一节指导书发给他分析一下）。

终端1：启动QEMU模拟器

在项目目录下执行：

make debug

这个命令会启动我们新编译的调试版QEMU，并暂停在初始状态。
终端2：附加调试QEMU进程

首先，我们需要找到QEMU进程的PID：

pgrep -f qemu-system-riscv64 #这个命令怎么来的呢，应该不难猜吧

记住这个PID，然后启动GDB并附加到这个进程：

sudo gdb

在GDB会话中执行：

    须知

    这里经过了很多的调整，比如，handle SIGPIPE nostop noprint这一句就是其中出现问题之后，我将命令行的输出提问给了大模型，它给我的回答。尝试一下，如果不运行这一句指令，会出现什么后果，让大模型为你分析一下这是怎么回事

(gdb) attach <刚才查到的PID>
(gdb) handle SIGPIPE nostop noprint
(gdb) # 你可以在这里执行一些操作，设置一些断点等
(gdb) continue # 之后就启动执行

终端3：调试ucore内核

在gdb已经设置好断点并启动qemu的执行（即执行了continue）之后，在项目目录下执行：

make gdb

这个GDB会话会连接到QEMU的GDB stub，就像我们平时调试内核一样。你可以在这里控制ucore的执行，比如打断点让它在某个访存指令处暂停、通过指令查看寄存器的值，某个符号的地址等。

    须知

    这个地方有必要讲一下，我们之前尝试过在某个符号打断点，比如b kern_entry，最后就会显示为在0x80200000处打上了断点，也可以直接打在某个位置，那么我们怎么知道任意一条指令的地址呢，询问了LLM之后，它给我的答案是我可以直接调试ucore代码，单步执行的过程中，gdb会显示每条指令的地址，$pc中也是当前指令的地址，我们就可以找到某个访存指令用于测试。

观察完整的地址转换流程

现在，三个终端已经建立了一个完整的调试环境：

在终端3中，让ucore执行到特定的访存指令。当访存发生时，终端2的GDB会在我们设置的断点处中断，在终端2中，你可以单步执行QEMU源码，观察TLB查询（明示）、页表遍历的具体过程

继续执行后，控制权回到终端3，可以继续调试ucore。

通过这种设置，我们实际上建立了一个从ucore用户程序发出访存请求，到QEMU模拟硬件MMU处理流程的完整观察链路。这种"透视"能力对于深入理解虚拟内存机制是极其宝贵的。

    思考

    前文中，我们的思路是，执行ucore到某个访存指令，然后再在qemu的源码打上断点，去单步执行，有没有更简单的思路呢，应该是有的，好好思考一下，想不到就问问大模型我们可以这么想，既然是访存，哪个指令并不重要，访问的地址很重要，我只需要找到某个一定会被访问的内存地址，然后在你找到的qemu的关键代码处打上一个条件断点，比如，在某个关键函数入口点判断传入的地址参数addr是不是我们要观测的地址（当然你最好知道这个地址是的的确确被访问到的，比如，当我们将要跳转到内核的C入口点的时候，内核C入口点的地址就是我们一定要访存的地址）。那么我们就不用调试ucore代码，只要在一开始就在qemu中打好条件断点，然后启动ucore执行，就自然会在合适的时间停在合适的位置。

这种双重调试的方法虽然设置起来稍显复杂，但它为我们打开了一扇观察计算机系统底层运作的窗口。当你亲眼看到软件如何精确模拟硬件行为时，很多抽象的概念都会变得具体而清晰。

    须知

    我们已经给出了基础的操作流程，以下是我们调试时可以参考的一些策略

        如何在qemu源码中找到和地址翻译有关的代码片段呢，如何开始调试？当然是慢慢找，大模型或许可以给你一个好点的答案（明示），我们期望同学们在大模型的帮助下简单理解qemu的源码，当然，并不需要同学们在短时间内完全理解如此大的一个项目，那不现实，但是在大模型的帮助下找到一些关键的代码位置还是各位应当掌握的能力的，一些嵌入到ide的大模型可能也能发挥很大的作用。
        某个函数入口点（例如一个"翻译函数"）可能在每个地址都会在qemu运行的时候调用翻译一遍，如果每次都停下来再按c（continue），那真就是一个代码调一天了，gdb提供的条件断点功能或许可以帮到大家，我们可以在代码中找到某个访存指令的位置，然后查看一下这个指令的访问的地址，然后在"翻译函数"打断点的时候设置一个条件，也就是address是否等于"我们期望的地址"，这样可以节省很多时间，关于条件断点的更多复杂应用，我也不会同学们可以让大模型当你的智能体。
        我们本次的实验重在体验一下在大模型的帮助下调试的流程，正如助教所言，这是一个开发世界体验项目，助教的思路也仅供参考，各位的操作合理即可，或许能开发出新的玩法，学到新的知识。

调试要求（附赠部分助教使用的问题）

    尝试理解我们调试流程中涉及到的qemu的源码，给出关键的调用路径，以及路径上一些关键的分支语句（不是让你只看分支语句），并通过调试演示某个访存指令访问的虚拟地址是如何在qemu的模拟中被翻译成一个物理地址的。
    单步调试页表翻译的部分，解释一下关键的操作流程。（这段是地址翻译的流程吗，我还是没有理解，给我解释的详细一点 / 这三个循环是在做什么，这两行的操作是从当前页表取出页表项吗，我还是没有理解）
    是否能够在qemu-4.1.1的源码中找到模拟cpu查找tlb的C代码，通过调试说明其中的细节。（按照riscv的流程，是不是应该先查tlb，tlbmiss之后才从页表中查找，给我找一下查找tlb的代码）
    仍然是tlb，qemu中模拟出来的tlb和我们真实cpu中的tlb有什么逻辑上的区别（提示：可以尝试找一条未开启虚拟地址空间的访存语句进行调试，看看调用路径，和开启虚拟地址空间之后的访存语句对比）
    记录下你调试过程中比较抓马有趣的细节，以及在观察模拟器通过软件模拟硬件执行的时候了解到的知识。
    记录实验过程中，有哪些通过大模型解决的问题，记录下当时的情景，你的思路，以及你和大模型交互的过程。

