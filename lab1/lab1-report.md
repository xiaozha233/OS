## 实验一 报告

**小组成员:**

| 姓名 | 学号 | 任务分工 |
| :--- | :--- | :--- |
| 陈翔 | 2314035 | 完成练习1解答，总结链接脚本知识点 |
| 查许琴 | 2314076 | 完成练习2解答，负责GDB调试与截图 |
| 刘璇 | 2313255 | 完成思考题，整合最终报告并校对 |

**仓库地址:** [https://github.com/xiaozha233/OS.git](https://github.com/xiaozha233/OS.git)

---

### 一、 实验目的

本次实验的核心目标为，构建一个最基础、最小化的操作系统内核。通过这个过程，深入理解操作系统启动的完整流程，具体包括：

1.  **掌握启动链:** 学习和理解在QEMU模拟的RISC-V平台上，从硬件加电复位开始，控制权如何通过MROM、OpenSBI固件，最终传递到我们编写的内核代码。
2.  **理解内存布局:** 学习如何使用链接脚本（Linker Script）来精确控制内核代码和数据在内存中的布局，确保内核被正确加载到OpenSBI期望的`0x80200000`地址。
3.  **构建底层I/O:** 学习在没有标准库支持的裸机环境下，如何通过RISC-V的`ecall`指令调用OpenSBI固件提供的服务，并在此基础上层层封装，最终实现一个类似`printf`的格式化输出函数`cprintf`。
4.  **熟悉调试工具:** 初步掌握使用GDB和QEMU进行远程调试的方法，为后续更复杂的内核开发打下坚实的基础。

---

### 二、 实验练习解答

#### **练习1：理解内核启动中的程序入口操作**

**1. 指令 `la sp, bootstacktop` 完成了什么操作，目的是什么？**

**2. 指令 `tail kern_init` 完成了什么操作，目的是什么？**



#### **练习2: 使用GDB验证启动流程**

**1. 调试过程、观察结果和问题答案**

*   **调试过程记录:**
    我们分别在两个终端输入make debug和make gdb命令启动调试：
    ![alt text](74edd736fa6aec268ed0c192764b2e07.png)
    ![alt text](de512e59f3995a90d75e0e8e25be13d6.png)
    GDB成功连接后，显示程序暂停在地址 `0x0000000000001000 in ?? ()`。这表明，QEMU模拟的RISC-V硬件加电后，CPU执行的第一条指令位于物理地址 `0x1000`。
    我们使用 `x/5i 0x1000` 命令来反汇编该地址处的指令，得到的**实际输出**如下：
    ![alt text](image.png)

    为了验证完整的启动链，我们在内核的入口地址 `0x80200000` 处设置断点 `b *0x80200000`，然后输入 `c` 继续执行。程序正确地停在了`kern/init/entry.S`的`kern_entry`处，证明了从`0x1000`开始的固件最终成功将控制权交给了我们的内核：
    ![alt text](image-1.png)
*   **问题回答:**
    **RISC-V 硬件加电后最初执行的几条指令位于什么地址？它们主要完成了哪些功能？**
    *   **地址:** 位于物理地址 **`0x1000`**。这是QEMU为该`virt`机器指定的硬件复位向量地址。
    
    *   **主要功能:** 位于此处的代码是固化在**MROM**（Machine ROM）中的一小段底层初始化程序，是整个启动链的起点。根据我实际调试观察到的汇编指令，它们主要完成了以下功能：
        1.  `auipc t0, 0x0`: 获取当前指令的地址，即`0x1000`，存入`t0`寄存器。这是实现地址无关代码的常用技巧。
        2.  `addi a1, t0, 32`: 计算`0x1000 + 32 = 0x1020`，并将结果存入`a1`寄存器。`a1`是第二个函数参数寄存器，这里可能是在为接下来的跳转准备参数。
        3.  `csrr a0, mhartid`: 读取`mhartid`（硬件线程ID）这个控制状态寄存器(CSR)，将其存入`a0`。这用于识别当前是哪个CPU核心在执行代码。
        4.  `ld t0, 24(t0)`: 从内存地址`t0 + 24`（即`0x1000 + 24 = 0x1018`）处加载一个8字节（双字）的值到`t0`寄存器。这个值是下一阶段引导程序的入口地址，被硬编码在MROM中。
        5.  `jr t0`: 跳转到刚刚从内存加载到`t0`寄存器中的地址去执行。
   

    **总结来说，** MROM的这段代码功能非常纯粹：**进行最基础的CPU状态识别（读取核心ID），然后从MROM的一个预定义位置加载下一阶段引导程序（即OpenSBI）的入口地址，最后无条件跳转过去**，从而完成启动接力赛的第一棒。
---

### 三、 重要知识点总结


---

### 四、 思考题（原理与实验的映射）

**1. 列出你认为本实验中重要的知识点，以及与对应的OS原理中的知识点，并简要说明你对二者的含义，关系，差异等方面的理解（也可能出现实验中的知识点没有对应的原理知识点）**

**2. 列出你认为OS原理中很重要，但在实验中没有对应上的知识点**

